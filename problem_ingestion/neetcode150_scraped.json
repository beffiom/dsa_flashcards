[
  {
    "uuid": "f5d72a3d-f07c-47d5-b21e-fb04248cb9c0",
    "card_name": "Contains Duplicate",
    "description": "Given an integer array nums , return true if any value appears more than once in the array, otherwise return false .\n\nExample 1:\n\nInput:nums=[1,2,3,3]Output:true\n\nExample 2:\n\nInput:nums=[1,2,3,4]Output:false",
    "python_code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        return len(set(nums)) < len(nums)",
    "dsa": "Hash Set Length",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/contains-duplicate/",
    "neetcode_link": "https://neetcode.io/problems/duplicate-integer?list=neetcode150"
  },
  {
    "uuid": "6d9d03b9-0660-4e28-93de-40163ea98e29",
    "card_name": "Valid Anagram",
    "description": "Given two strings s and t , return true if the two strings are anagrams of each other, otherwise return false .\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput:s=\"racecar\",t=\"carrace\"Output:true\n\nExample 2:\n\nInput:s=\"jar\",t=\"jam\"Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count = [0] * 26\n        for i in range(len(s)):\n            count[ord(s[i]) - ord('a')] += 1\n            count[ord(t[i]) - ord('a')] -= 1\n\n        for val in count:\n            if val != 0:\n                return False\n        return True",
    "dsa": "Hash Table (Using Array)",
    "time_complexity": "O(n + m)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/valid-anagram/",
    "neetcode_link": "https://neetcode.io/problems/is-anagram?list=neetcode150"
  },
  {
    "uuid": "437a7007-fc46-4138-bec5-8adab33036f2",
    "card_name": "Two Sum",
    "description": "Given an array of integers nums and an integer target , return the indices i and j such that nums[i] + nums[j] == target and i != j .\n\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\n\nReturn the answer with the smaller index first.\n\nExample 1:\n\nInput:nums=[3,4,5,6],target=7Output:[0,1]\n\nExplanation: nums[0] + nums[1] == 7 , so we return [ 0 , 1 ] .\n\nExample 2:\n\nInput:nums=[4,5,6],target=10Output:[0,2]\n\nExample 3:\n\nInput:nums=[5,5],target=10Output:[0,1]\n\nConstraints:",
    "python_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i",
    "dsa": "Hash Map (One Pass)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/two-sum/",
    "neetcode_link": "https://neetcode.io/problems/two-integer-sum?list=neetcode150"
  },
  {
    "uuid": "e4119b19-6461-4cf8-ae9a-b3fe65ea955f",
    "card_name": "Group Anagrams",
    "description": "Given an array of strings strs , group all anagrams together into sublists. You may return the output in any order .\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput:strs=[\"act\",\"pots\",\"tops\",\"cat\",\"stop\",\"hat\"]Output:[[\"hat\"],[\"act\",\"cat\"],[\"stop\",\"pots\",\"tops\"]]\n\nExample 2:\n\nInput:strs=[\"x\"]Output:[[\"x\"]]\n\nExample 3:\n\nInput:strs=[\"\"]Output:[[\"\"]]\n\nConstraints:",
    "python_code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        res = defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            res[tuple(count)].append(s)\n        return list(res.values())",
    "dsa": "Hash Table",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/group-anagrams/",
    "neetcode_link": "https://neetcode.io/problems/anagram-groups?list=neetcode150"
  },
  {
    "uuid": "c9b81ee6-6f7a-4ad2-8a06-0fa6457ae0ec",
    "card_name": "Top K Frequent Elements",
    "description": "Given an integer array nums and an integer k , return the k most frequent elements within the array.\n\nThe test cases are generated such that the answer is always unique .\n\nYou may return the output in any order .\n\nExample 1:\n\nInput:nums=[1,2,2,3,3,3],k=2Output:[2,3]\n\nExample 2:\n\nInput:nums=[7,7],k=1Output:[7]\n\nConstraints:",
    "python_code": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]\n\n        for num in nums:\n            count[num] = 1 + count.get(num, 0)\n        for num, cnt in count.items():\n            freq[cnt].append(num)\n\n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            for num in freq[i]:\n                res.append(num)\n                if len(res) == k:\n                    return res",
    "dsa": "Bucket Sort",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/top-k-frequent-elements/",
    "neetcode_link": "https://neetcode.io/problems/top-k-elements-in-list?list=neetcode150"
  },
  {
    "uuid": "6739e898-ae0f-4c58-a40e-a87ef8d288d4",
    "card_name": "Encode and Decode Strings",
    "description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement encode and decode\n\nExample 1:\n\nInput:[\"neet\",\"code\",\"love\",\"you\"]Output:[\"neet\",\"code\",\"love\",\"you\"]\n\nExample 2:\n\nInput:[\"we\",\"say\",\":\",\"yes\"]Output:[\"we\",\"say\",\":\",\"yes\"]\n\nConstraints:",
    "python_code": "class Solution:\n\n    def encode(self, strs: List[str]) -> str:\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    def decode(self, s: str) -> List[str]:\n        res = []\n        i = 0\n\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            i = j + 1\n            j = i + length\n            res.append(s[i:j])\n            i = j\n\n        return res",
    "dsa": "Encoding & Decoding (Optimal)",
    "time_complexity": "O(m)",
    "space_complexity": "O(m + n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/encode-and-decode-strings/",
    "neetcode_link": "https://neetcode.io/problems/string-encode-and-decode?list=neetcode150"
  },
  {
    "uuid": "9f6541b2-dcbf-47b6-b629-9150175e2f4d",
    "card_name": "Product of Array Except Self",
    "description": "Given an integer array nums , return an array output where output[i] is the product of all the elements of nums except nums[i] .\n\nEach product is guaranteed to fit in a 32-bit integer.\n\nFollow-up: Could you solve it in O ( n ) O(n) O ( n ) time without using the division operation?\n\nExample 1:\n\nInput:nums=[1,2,4,6]Output:[48,24,12,8]\n\nExample 2:\n\nInput:nums=[-1,0,1,2,3]Output:[0,-6,0,0,0]\n\nConstraints:",
    "python_code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * (len(nums))\n\n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res",
    "dsa": "Prefix & Suffix (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/product-of-array-except-self/",
    "neetcode_link": "https://neetcode.io/problems/products-of-array-discluding-self?list=neetcode150"
  },
  {
    "uuid": "ba9c3d1f-bf0f-471a-be30-0449e3859d26",
    "card_name": "Valid Sudoku",
    "description": "You are given a 9 x 9 Sudoku board board . A Sudoku board is valid if the following rules are followed:\n\nReturn true if the Sudoku board is valid, otherwise return false\n\nNote: A board does not need to be full or be solvable to be valid.\n\nExample 1:\n\nInput:board=[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]Output:true\n\nExample 2:\n\nInput:board=[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\"1\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]Output:false\n\nExplanation: There are two 1's in the top-left 3x3 sub-box.\n\nConstraints:",
    "python_code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [0] * 9\n        cols = [0] * 9\n        squares = [0] * 9\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n\n                val = int(board[r][c]) - 1\n                if (1 << val) & rows[r]:\n                    return False\n                if (1 << val) & cols[c]:\n                    return False\n                if (1 << val) & squares[(r // 3) * 3 + (c // 3)]:\n                    return False\n\n                rows[r] |= (1 << val)\n                cols[c] |= (1 << val)\n                squares[(r // 3) * 3 + (c // 3)] |= (1 << val)\n\n        return True",
    "dsa": "Bitmask",
    "time_complexity": "O(n ^ 2)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/valid-sudoku/",
    "neetcode_link": "https://neetcode.io/problems/valid-sudoku?list=neetcode150"
  },
  {
    "uuid": "9c80d819-099f-4b60-bf47-b34d2ec7d9fc",
    "card_name": "Longest Consecutive Sequence",
    "description": "Given an array of integers nums , return the length of the longest consecutive sequence of elements that can be formed.\n\nA consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample 1:\n\nInput:nums=[2,20,4,10,3,4,5]Output:4\n\nExplanation: The longest consecutive sequence is [ 2 , 3 , 4 , 5 ] .\n\nExample 2:\n\nInput:nums=[0,3,2,5,4,6,1,1]Output:7\n\nConstraints:",
    "python_code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        mp = defaultdict(int)\n        res = 0\n\n        for num in nums:\n            if not mp[num]:\n                mp[num] = mp[num - 1] + mp[num + 1] + 1\n                mp[num - mp[num - 1]] = mp[num]\n                mp[num + mp[num + 1]] = mp[num]\n                res = max(res, mp[num])\n        return res",
    "dsa": "Hash Map",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/longest-consecutive-sequence/",
    "neetcode_link": "https://neetcode.io/problems/longest-consecutive-sequence?list=neetcode150"
  },
  {
    "uuid": "25aa0214-64d6-494c-8700-0bac7b8bb15e",
    "card_name": "Valid Palindrome",
    "description": "Given a string s , return true if it is a palindrome , otherwise return false .\n\nA palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.\n\nNote: Alphanumeric characters consist of letters ( A-Z , a-z ) and numbers (0-9) .\n\nExample 1:\n\nInput:s=\"Was it a car or a cat I saw?\"Output:true\n\nExplanation: After considering only alphanumerical characters we have \"wasitacaroracatisaw\", which is a palindrome.\n\nExample 2:\n\nInput:s=\"tab a cat\"Output:false\n\nExplanation: \"tabacat\" is not a palindrome.\n\nConstraints:",
    "python_code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            while l < r and not self.alphaNum(s[l]):\n                l += 1\n            while r > l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True\n\n    def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or\n                ord('a') <= ord(c) <= ord('z') or\n                ord('0') <= ord(c) <= ord('9'))",
    "dsa": "Two Pointers",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/valid-palindrome/",
    "neetcode_link": "https://neetcode.io/problems/is-palindrome?list=neetcode150"
  },
  {
    "uuid": "45f90b59-83f5-4aec-844b-836118e32f32",
    "card_name": "Two Sum II Input Array Is Sorted",
    "description": "Given an array of integers numbers that is sorted in non-decreasing order .\n\nReturn the indices ( 1-indexed ) of two numbers, [index1, index2] , such that they add up to a given target number target and index1 < index2 . Note that index1 and index2 cannot be equal, therefore you may not use the same element twice.\n\nThere will always be exactly one valid solution .\n\nYour solution must use O ( 1 ) O(1) O ( 1 ) additional space.\n\nExample 1:\n\nInput:numbers=[1,2,3,4],target=3Output:[1,2]\n\nExplanation: The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, index1 = 1, index2 = 2. We return [ 1 , 2 ] .\n\nConstraints:",
    "python_code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]\n        return []",
    "dsa": "Two Pointers",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
    "neetcode_link": "https://neetcode.io/problems/two-integer-sum-ii?list=neetcode150"
  },
  {
    "uuid": "283bff6c-9363-466c-95aa-d1cc23431d78",
    "card_name": "3Sum",
    "description": "Given an integer array nums , return all the triplets [nums[i], nums[j], nums[k]] where nums[i] + nums[j] + nums[k] == 0 , and the indices i , j and k are all distinct.\n\nThe output should not contain any duplicate triplets. You may return the output and the triplets in any order .\n\nExample 1:\n\nInput:nums=[-1,0,1,2,-1,-4]Output:[[-1,-1,2],[-1,0,1]]\n\nExplanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2] .\n\nExample 2:\n\nInput:nums=[0,1,1]Output:[]\n\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput:nums=[0,0,0]Output:[[0,0,0]]\n\nExplanation: The only possible triplet sums up to 0.\n\nConstraints:",
    "python_code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n\n        return res",
    "dsa": "Two Pointers",
    "time_complexity": "O(n ^ 2)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/3sum/",
    "neetcode_link": "https://neetcode.io/problems/three-integer-sum?list=neetcode150"
  },
  {
    "uuid": "d9a9f381-7d79-44fb-83b0-986636c2ed28",
    "card_name": "Container With Most Water",
    "description": "You are given an integer array heights where heights[i] represents the height of the i t h i^{th} i t h bar.\n\nYou may choose any two bars to form a container. Return the maximum amount of water a container can store.\n\nExample 1:\n\nInput:height=[1,7,2,5,4,7,3,6]Output:36\n\nExample 2:\n\nInput:height=[2,2,2]Output:4\n\nConstraints:",
    "python_code": "class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        l, r = 0, len(heights) - 1\n        res = 0\n\n        while l < r:\n            area = min(heights[l], heights[r]) * (r - l)\n            res = max(res, area)\n            if heights[l] <= heights[r]:\n                l += 1\n            else:\n                r -= 1\n        return res",
    "dsa": "Two Pointers",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/container-with-most-water/",
    "neetcode_link": "https://neetcode.io/problems/max-water-container?list=neetcode150"
  },
  {
    "uuid": "465d120b-5538-4e96-8904-f51c11a4e3a4",
    "card_name": "Trapping Rain Water",
    "description": "You are given an array of non-negative integers height which represent an elevation map. Each value height[i] represents the height of a bar, which has a width of 1 .\n\nReturn the maximum area of water that can be trapped between the bars.\n\nExample 1:\n\nInput:height=[0,2,0,3,1,0,1,3,2,1]Output:9\n\nConstraints:",
    "python_code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res",
    "dsa": "Two Pointers",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/trapping-rain-water/",
    "neetcode_link": "https://neetcode.io/problems/trapping-rain-water?list=neetcode150"
  },
  {
    "uuid": "ac4c173a-6f2c-453f-b06b-6d0252292620",
    "card_name": "Best Time to Buy And Sell Stock",
    "description": "You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.\n\nYou may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.\n\nReturn the maximum profit you can achieve. You may choose to not make any transactions , in which case the profit would be 0 .\n\nExample 1:\n\nInput:prices=[10,1,5,6,7,1]Output:6\n\nExplanation: Buy prices[1] and sell prices[4] , profit = 7 - 1 = 6 .\n\nExample 2:\n\nInput:prices=[10,8,7,5,2]Output:0\n\nExplanation: No profitable transactions can be made, thus the max profit is 0.\n\nConstraints:",
    "python_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxP = 0\n        minBuy = prices[0]\n\n        for sell in prices:\n            maxP = max(maxP, sell - minBuy)\n            minBuy = min(minBuy, sell)\n        return maxP",
    "dsa": "Dynamic Programming",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
    "neetcode_link": "https://neetcode.io/problems/buy-and-sell-crypto?list=neetcode150"
  },
  {
    "uuid": "40542959-eba0-4542-bf92-d06fb946284a",
    "card_name": "Longest Substring Without Repeating Characters",
    "description": "Given a string s , find the length of the longest substring without duplicate characters.\n\nA substring is a contiguous sequence of characters within a string.\n\nExample 1:\n\nInput:s=\"zxyzxyz\"Output:3\n\nExplanation: The string \"xyz\" is the longest without duplicate characters.\n\nExample 2:\n\nInput:s=\"xxxx\"Output:1\n\nConstraints:",
    "python_code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        mp = {}\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            if s[r] in mp:\n                l = max(mp[s[r]] + 1, l)\n            mp[s[r]] = r\n            res = max(res, r - l + 1)\n        return res",
    "dsa": "Sliding Window (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(m)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
    "neetcode_link": "https://neetcode.io/problems/longest-substring-without-duplicates?list=neetcode150"
  },
  {
    "uuid": "a79216b3-8e9a-4714-8a7a-eae707c6fda6",
    "card_name": "Longest Repeating Character Replacement",
    "description": "You are given a string s consisting of only uppercase english characters and an integer k . You can choose up to k characters of the string and replace them with any other uppercase English character.\n\nAfter performing at most k replacements, return the length of the longest substring which contains only one distinct character.\n\nExample 1:\n\nInput:s=\"XYYX\",k=2Output:4\n\nExplanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.\n\nExample 2:\n\nInput:s=\"AAABABB\",k=1Output:5\n\nConstraints:",
    "python_code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        res = 0\n\n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            while (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n            res = max(res, r - l + 1)\n\n        return res",
    "dsa": "Sliding Window (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(m)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/longest-repeating-character-replacement/",
    "neetcode_link": "https://neetcode.io/problems/longest-repeating-substring-with-replacement?list=neetcode150"
  },
  {
    "uuid": "639b4338-1176-4f33-ba28-ccaf1a260c30",
    "card_name": "Permutation In String",
    "description": "You are given two strings s1 and s2 .\n\nReturn true if s2 contains a permutation of s1 , or false otherwise. That means if a permutation of s1 exists as a substring of s2 , then return true .\n\nBoth strings only contain lowercase letters.\n\nExample 1:\n\nInput:s1=\"abc\",s2=\"lecabee\"Output:true\n\nExplanation: The substring \"cab\" is a permutation of \"abc\" and is present in \"lecabee\" .\n\nExample 2:\n\nInput:s1=\"abc\",s2=\"lecaabee\"Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord('a')] += 1\n            s2Count[ord(s2[i]) - ord('a')] += 1\n\n        matches = 0\n        for i in range(26):\n            matches += (1 if s1Count[i] == s2Count[i] else 0)\n\n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n\n            index = ord(s2[r]) - ord('a')\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord('a')\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26",
    "dsa": "Sliding Window",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/permutation-in-string/",
    "neetcode_link": "https://neetcode.io/problems/permutation-string?list=neetcode150"
  },
  {
    "uuid": "23311ec3-6751-4c74-a694-12754630469f",
    "card_name": "Minimum Window Substring",
    "description": "Given two strings s and t , return the shortest substring of s such that every character in t , including duplicates, is present in the substring. If such a substring does not exist, return an empty string \"\" .\n\nYou may assume that the correct output is always unique.\n\nExample 1:\n\nInput:s=\"OUZODYXAZV\",t=\"XYZ\"Output:\"YXAZ\"\n\nExplanation: \"YXAZ\" is the shortest substring that includes \"X\" , \"Y\" , and \"Z\" from string t .\n\nExample 2:\n\nInput:s=\"xyz\",t=\"xyz\"Output:\"xyz\"\n\nExample 3:\n\nInput:s=\"x\",t=\"xy\"Output:\"\"\n\nConstraints:",
    "python_code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\":\n            return \"\"\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have += 1\n\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"",
    "dsa": "Sliding Window",
    "time_complexity": "O(n)",
    "space_complexity": "O(m)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/minimum-window-substring/",
    "neetcode_link": "https://neetcode.io/problems/minimum-window-with-characters?list=neetcode150"
  },
  {
    "uuid": "eb4e9d2a-ab61-4668-9084-774a0e820c8d",
    "card_name": "Sliding Window Maximum",
    "description": "You are given an array of integers nums and an integer k . There is a sliding window of size k that starts at the left edge of the array. The window slides one position to the right until it reaches the right edge of the array.\n\nReturn a list that contains the maximum element in the window at each step.\n\nExample 1:\n\nInput:nums=[1,2,1,0,4,2,6],k=3Output:[2,2,4,4,6]Explanation:WindowpositionMax--------------------[121]042621[210]426212[104]264121[042]641210[426]6\n\nConstraints:",
    "python_code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = deque()  # index\n        l = r = 0\n\n        while r < len(nums):\n            while q and nums[q[-1]] < nums[r]:\n                q.pop()\n            q.append(r)\n\n            if l > q[0]:\n                q.popleft()\n\n            if (r + 1) >= k:\n                output.append(nums[q[0]])\n                l += 1\n            r += 1\n\n        return output",
    "dsa": "Deque",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/sliding-window-maximum/",
    "neetcode_link": "https://neetcode.io/problems/sliding-window-maximum?list=neetcode150"
  },
  {
    "uuid": "aa1cd8bb-078a-4523-9b3b-b9f76b63eb53",
    "card_name": "Valid Parentheses",
    "description": "You are given a string s consisting of the following characters: '(' , ')' , '{' , '}' , '[' and ']' .\n\nThe input string s is valid if and only if:\n\nReturn true if s is a valid string, and false otherwise.\n\nExample 1:\n\nInput:s=\"[]\"Output:true\n\nExample 2:\n\nInput:s=\"([{}])\"Output:true\n\nExample 3:\n\nInput:s=\"[(])\"Output:false\n\nExplanation: The brackets are not closed in the correct order.\n\nConstraints:",
    "python_code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        closeToOpen = { \")\" : \"(\", \"]\" : \"[\", \"}\" : \"{\" }\n\n        for c in s:\n            if c in closeToOpen:\n                if stack and stack[-1] == closeToOpen[c]:\n                    stack.pop()\n                else:\n                    return False\n            else:\n                stack.append(c)\n\n        return True if not stack else False",
    "dsa": "Stack",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/valid-parentheses/",
    "neetcode_link": "https://neetcode.io/problems/validate-parentheses?list=neetcode150"
  },
  {
    "uuid": "c7622d58-45ea-4ceb-9f3d-c93e87bd48a9",
    "card_name": "Min Stack",
    "description": "Design a stack class that supports the push , pop , top , and getMin operations.\n\nEach function should run in O ( 1 ) O(1) O ( 1 ) time.\n\nExample 1:\n\nInput:[\"MinStack\",\"push\",1,\"push\",2,\"push\",0,\"getMin\",\"pop\",\"top\",\"getMin\"]Output:[null,null,null,null,0,null,2,1]Explanation:MinStackminStack=newMinStack();minStack.push(1);minStack.push(2);minStack.push(0);minStack.getMin();// return 0minStack.pop();minStack.top();// return 2minStack.getMin();// return 1\n\nConstraints:",
    "python_code": "class MinStack:\n    def __init__(self):\n        self.min = float('inf')\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        if not self.stack:\n            self.stack.append(0)\n            self.min = val\n        else:\n            self.stack.append(val - self.min)\n            if val < self.min:\n                self.min = val\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n\n        pop = self.stack.pop()\n\n        if pop < 0:\n            self.min = self.min - pop\n\n    def top(self) -> int:\n        top = self.stack[-1]\n        if top > 0:\n            return top + self.min\n        else:\n            return self.min\n\n    def getMin(self) -> int:\n        return self.min",
    "dsa": "One Stack",
    "time_complexity": "O(1)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/min-stack/",
    "neetcode_link": "https://neetcode.io/problems/minimum-stack?list=neetcode150"
  },
  {
    "uuid": "6896c2fb-5870-4731-9c4b-610de08b4e36",
    "card_name": "Evaluate Reverse Polish Notation",
    "description": "You are given an array of strings tokens that represents a valid arithmetic expression in Reverse Polish Notation .\n\nReturn the integer that represents the evaluation of the expression.\n\nExample 1:\n\nInput:tokens=[\"1\",\"2\",\"+\",\"3\",\"*\",\"4\",\"-\"]Output:5Explanation:((1+2)*3)-4=5\n\nConstraints:",
    "python_code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]",
    "dsa": "Stack",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
    "neetcode_link": "https://neetcode.io/problems/evaluate-reverse-polish-notation?list=neetcode150"
  },
  {
    "uuid": "8b35838f-0604-49d9-8dc5-cb55df5d2061",
    "card_name": "Generate Parentheses",
    "description": "You are given an integer n . Return all well-formed parentheses strings that you can generate with n pairs of parentheses.\n\nExample 1:\n\nInput:n=1Output:[\"()\"]\n\nExample 2:\n\nInput:n=3Output:[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nYou may return the answer in any order .\n\nConstraints:",
    "python_code": "class Solution:\n    def generateParenthesis(self, n):\n        res = [[] for _ in range(n+1)]\n        res[0] = [\"\"]\n\n        for k in range(n + 1):\n            for i in range(k):\n                for left in res[i]:\n                    for right in res[k-i-1]:\n                        res[k].append(\"(\" + left + \")\" + right)\n\n        return res[-1]",
    "dsa": "Dynamic Programming",
    "time_complexity": "O(\\frac{4^n}{\\sqrt{n}})",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/generate-parentheses/",
    "neetcode_link": "https://neetcode.io/problems/generate-parentheses?list=neetcode150"
  },
  {
    "uuid": "49d81786-83a1-466c-b94a-d3cbd7412c4d",
    "card_name": "Daily Temperatures",
    "description": "You are given an array of integers temperatures where temperatures[i] represents the daily temperatures on the ith day.\n\nReturn an array result where result [ i ] is the number of days after the ith day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the ith day, set result [ i ] to 0 instead.\n\nExample 1:\n\nInput:temperatures=[30,38,30,36,35,40,28]Output:[1,4,1,2,1,0,0]\n\nExample 2:\n\nInput:temperatures=[22,21,20]Output:[0,0,0]\n\nConstraints:",
    "python_code": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        n = len(temperatures)\n        res = [0] * n\n\n        for i in range(n - 2, -1, -1):\n            j = i + 1\n            while j < n and temperatures[j] <= temperatures[i]:\n                if res[j] == 0:\n                    j = n\n                    break\n                j += res[j]\n\n            if j < n:\n                res[i] = j - i\n        return res",
    "dsa": "Dynamic Programming",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/daily-temperatures/",
    "neetcode_link": "https://neetcode.io/problems/daily-temperatures?list=neetcode150"
  },
  {
    "uuid": "a99ea07e-9809-4fb8-a0af-3ea6096eaa25",
    "card_name": "Car Fleet",
    "description": "There are n cars traveling to the same destination on a one-lane highway.\n\nYou are given two arrays of integers position and speed , both of length n .\n\nThe destination is at position target miles.\n\nA car can not pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.\n\nA car fleet is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.\n\nIf a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.\n\nReturn the number of different car fleets that will arrive at the destination.\n\nExample 1:\n\nInput:target=10,position=[1,4],speed=[3,2]Output:1\n\nExplanation: The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.\n\nExample 2:\n\nInput:target=10,position=[4,1,0,7],speed=[2,2,1,1]Output:3\n\nExplanation: The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.\n\nConstraints:",
    "python_code": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n\n        fleets = 1\n        prevTime = (target - pair[0][0]) / pair[0][1]\n        for i in range(1, len(pair)):\n            currCar = pair[i]\n            currTime = (target - currCar[0]) / currCar[1]\n            if currTime > prevTime:\n                fleets += 1\n                prevTime = currTime\n        return fleets",
    "dsa": "Iteration",
    "time_complexity": "O(n \\log n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/car-fleet/",
    "neetcode_link": "https://neetcode.io/problems/car-fleet?list=neetcode150"
  },
  {
    "uuid": "f490bf78-4370-45ce-9442-96d22895b434",
    "card_name": "Largest Rectangle In Histogram",
    "description": "You are given an array of integers heights where heights[i] represents the height of a bar. The width of each bar is 1 .\n\nReturn the area of the largest rectangle that can be formed among the bars.\n\nNote: This chart is known as a histogram .\n\nExample 1:\n\nInput:heights=[7,1,7,2,2,4]Output:8\n\nExample 2:\n\nInput:heights=[1,3,7]Output:7\n\nConstraints:",
    "python_code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        maxArea = 0\n        stack = []\n\n        for i in range(n + 1):\n            while stack and (i == n  or heights[stack[-1]] >= heights[i]):\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                maxArea = max(maxArea, height * width)\n            stack.append(i)\n        return maxArea",
    "dsa": "Stack (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
    "neetcode_link": "https://neetcode.io/problems/largest-rectangle-in-histogram?list=neetcode150"
  },
  {
    "uuid": "6fe19681-6dc5-48fa-91c3-bab3b8da0cb7",
    "card_name": "Binary Search",
    "description": "You are given an array of distinct integers nums , sorted in ascending order, and an integer target .\n\nImplement a function to search for target within nums . If it exists, then return its index, otherwise, return -1 .\n\nYour solution must run in O ( l o g n ) O(log n) O ( l o g n ) time.\n\nExample 1:\n\nInput:nums=[-1,0,2,4,6,8],target=4Output:3\n\nExample 2:\n\nInput:nums=[-1,0,2,4,6,8],target=3Output:-1\n\nConstraints:",
    "python_code": "import bisect\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        index = bisect.bisect_left(nums, target)\n        return index if index < len(nums) and nums[index] == target else -1",
    "dsa": "Built-In Function",
    "time_complexity": "O(\\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/binary-search/",
    "neetcode_link": "https://neetcode.io/problems/binary-search?list=neetcode150"
  },
  {
    "uuid": "4d7d58fe-13fe-4f9a-8d27-312a433ecaef",
    "card_name": "Search a 2D Matrix",
    "description": "You are given an m x n 2-D integer array matrix and an integer target .\n\nReturn true if target exists within matrix or false otherwise.\n\nCan you write a solution that runs in O(log(m * n)) time?\n\nExample 1:\n\nInput:matrix=[[1,2,4,8],[10,11,12,13],[14,20,30,40]],target=10Output:true\n\nExample 2:\n\nInput:matrix=[[1,2,4,8],[10,11,12,13],[14,20,30,40]],target=15Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        l, r = 0, ROWS * COLS - 1\n        while l <= r:\n            m = l + (r - l) // 2\n            row, col = m // COLS, m % COLS\n            if target > matrix[row][col]:\n                l = m + 1\n            elif target < matrix[row][col]:\n                r = m - 1\n            else:\n                return True\n        return False",
    "dsa": "Binary Search (One Pass)",
    "time_complexity": "O(\\log(m * n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/search-a-2d-matrix/",
    "neetcode_link": "https://neetcode.io/problems/search-2d-matrix?list=neetcode150"
  },
  {
    "uuid": "5c7f6a60-08f3-4960-9212-ee57488bb7bf",
    "card_name": "Koko Eating Bananas",
    "description": "You are given an integer array piles where piles[i] is the number of bananas in the ith pile. You are also given an integer h , which represents the number of hours you have to eat all the bananas.\n\nYou may decide your bananas-per-hour eating rate of k . Each hour, you may choose a pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, you may finish eating the pile but you can not eat from another pile in the same hour.\n\nReturn the minimum integer k such that you can eat all the bananas within h hours.\n\nExample 1:\n\nInput:piles=[1,4,3,2],h=9Output:2\n\nExplanation: With an eating rate of 2, you can eat the bananas in 6 hours. With an eating rate of 1, you would need 10 hours to eat all the bananas (which exceeds h=9), thus the minimum eating rate is 2.\n\nExample 2:\n\nInput:piles=[25,10,23,4],h=4Output:25\n\nConstraints:",
    "python_code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime += math.ceil(float(p) / k)\n            if totalTime <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res",
    "dsa": "Binary Search",
    "time_complexity": "O(n * \\log m)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/koko-eating-bananas/",
    "neetcode_link": "https://neetcode.io/problems/eating-bananas?list=neetcode150"
  },
  {
    "uuid": "053a5911-560c-4e18-8869-53b531311a5a",
    "card_name": "Find Minimum In Rotated Sorted Array",
    "description": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:\n\nNotice that rotating the array 4 times moves the last four elements of the array to the beginning. Rotating the array 6 times produces the original array.\n\nAssuming all elements in the rotated sorted array nums are unique , return the minimum element of this array.\n\nA solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time ?\n\nExample 1:\n\nInput:nums=[3,4,5,6,1,2]Output:1\n\nExample 2:\n\nInput:nums=[4,5,0,1,2,3]Output:0\n\nExample 3:\n\nInput:nums=[4,5,6,7]Output:4\n\nConstraints:",
    "python_code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = l + (r - l) // 2\n            if nums[m] < nums[r]:\n                r = m\n            else:\n                l = m + 1\n        return nums[l]",
    "dsa": "Binary Search (Lower Bound)",
    "time_complexity": "O(\\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
    "neetcode_link": "https://neetcode.io/problems/find-minimum-in-rotated-sorted-array?list=neetcode150"
  },
  {
    "uuid": "bbb59d66-852f-4c29-8965-4749976a70f7",
    "card_name": "Search In Rotated Sorted Array",
    "description": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:\n\nGiven the rotated sorted array nums and an integer target , return the index of target within nums , or -1 if it is not present.\n\nYou may assume all elements in the sorted rotated array nums are unique ,\n\nA solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time ?\n\nExample 1:\n\nInput:nums=[3,4,5,6,1,2],target=1Output:4\n\nExample 2:\n\nInput:nums=[3,5,6,0,1,2],target=4Output:-1\n\nConstraints:",
    "python_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1",
    "dsa": "Binary Search (One Pass)",
    "time_complexity": "O(\\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
    "neetcode_link": "https://neetcode.io/problems/find-target-in-rotated-sorted-array?list=neetcode150"
  },
  {
    "uuid": "432ea9b1-da60-4cc0-951e-19ed6e5f0a5f",
    "card_name": "Time Based Key Value Store",
    "description": "Implement a time-based key-value data structure that supports:\n\nImplement the TimeMap class:\n\nNote: For all calls to set , the timestamps are in strictly increasing order.\n\nExample 1:\n\nInput:[\"TimeMap\",\"set\",[\"alice\",\"happy\",1],\"get\",[\"alice\",1],\"get\",[\"alice\",2],\"set\",[\"alice\",\"sad\",3],\"get\",[\"alice\",3]]Output:[null,null,\"happy\",\"happy\",null,\"sad\"]Explanation:TimeMaptimeMap=newTimeMap();timeMap.set(\"alice\",\"happy\",1);// store the key \"alice\" and value \"happy\" along with timestamp = 1.timeMap.get(\"alice\",1);// return \"happy\"timeMap.get(\"alice\",2);// return \"happy\",there is no value stored for timestamp 2,thus we return the value at timestamp 1.timeMap.set(\"alice\",\"sad\",3);// store the key \"alice\" and value \"sad\" along with timestamp = 3.timeMap.get(\"alice\",3);// return \"sad\"\n\nConstraints:",
    "python_code": "class TimeMap:\n\n    def __init__(self):\n        self.keyStore = {}  # key : list of [val, timestamp]\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.keyStore:\n            self.keyStore[key] = []\n        self.keyStore[key].append([value, timestamp])\n\n    def get(self, key: str, timestamp: int) -> str:\n        res, values = \"\", self.keyStore.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res",
    "dsa": "Binary Search (Array)",
    "time_complexity": "O(1)",
    "space_complexity": "O(m * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/time-based-key-value-store/",
    "neetcode_link": "https://neetcode.io/problems/time-based-key-value-store?list=neetcode150"
  },
  {
    "uuid": "d919a198-ecc8-43f8-866a-e4814e975f06",
    "card_name": "Median of Two Sorted Arrays",
    "description": "You are given two integer arrays nums1 and nums2 of size m and n respectively, where each is sorted in ascending order. Return the median value among all elements of the two arrays.\n\nYour solution must run in O ( l o g ( m + n ) ) O(log (m+n)) O ( l o g ( m + n )) time.\n\nExample 1:\n\nInput:nums1=[1,2],nums2=[3]Output:2.0\n\nExplanation: Among [ 1 , 2 , 3 ] the median is 2.\n\nExample 2:\n\nInput:nums1=[1,3],nums2=[2,4]Output:2.5\n\nExplanation: Among [ 1 , 2 , 3 , 4 ] the median is (2 + 3) / 2 = 2.5.\n\nConstraints:",
    "python_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2\n            j = half - i - 2\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1",
    "dsa": "Binary Search (Optimal)",
    "time_complexity": "O(\\log (min(n, m)",
    "space_complexity": "O(1)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "neetcode_link": "https://neetcode.io/problems/median-of-two-sorted-arrays?list=neetcode150"
  },
  {
    "uuid": "939a7f0b-adf7-44c4-ae7d-53fde7e1664b",
    "card_name": "Reverse Linked List",
    "description": "Given the beginning of a singly linked list head , reverse the list, and return the new beginning of the list.\n\nExample 1:\n\nInput:head=[0,1,2,3]Output:[3,2,1,0]\n\nExample 2:\n\nInput:head=[]Output:[]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev",
    "dsa": "Iteration",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/reverse-linked-list/",
    "neetcode_link": "https://neetcode.io/problems/reverse-a-linked-list?list=neetcode150"
  },
  {
    "uuid": "34e4e3f1-11a2-4d98-97ef-eda41f1a9b49",
    "card_name": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists list1 and list2 .\n\nMerge the two lists into one sorted linked list and return the head of the new sorted linked list.\n\nThe new list should be made up of nodes from list1 and list2 .\n\nExample 1:\n\nInput:list1=[1,2,4],list2=[1,3,5]Output:[1,1,2,3,4,5]\n\nExample 2:\n\nInput:list1=[],list2=[1,2]Output:[1,2]\n\nExample 3:\n\nInput:list1=[],list2=[]Output:[]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = node = ListNode()\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n\n        node.next = list1 or list2\n\n        return dummy.next",
    "dsa": "Iteration",
    "time_complexity": "O(n + m)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/merge-two-sorted-lists/",
    "neetcode_link": "https://neetcode.io/problems/merge-two-sorted-linked-lists?list=neetcode150"
  },
  {
    "uuid": "9fb23111-867b-48f5-8144-d39c01a35c1e",
    "card_name": "Linked List Cycle",
    "description": "Given the beginning of a linked list head , return true if there is a cycle in the linked list. Otherwise, return false .\n\nThere is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.\n\nInternally, index determines the index of the beginning of the cycle, if it exists. The tail node of the list will set it's next pointer to the index-th node. If index = -1 , then the tail node points to null and no cycle exists.\n\nNote: index is not given to you as a parameter.\n\nExample 1:\n\nInput:head=[1,2,3,4],index=1Output:true\n\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\n\nInput:head=[1,2],index=-1Output:false\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False",
    "dsa": "Fast And Slow Pointers",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/linked-list-cycle/",
    "neetcode_link": "https://neetcode.io/problems/linked-list-cycle-detection?list=neetcode150"
  },
  {
    "uuid": "4b16c045-5395-4a4c-a1d5-4fd724ea214e",
    "card_name": "Reorder List",
    "description": "You are given the head of a singly linked-list.\n\nThe positions of a linked list of length = 7 for example, can intially be represented as:\n\n[ 0 , 1 , 2 , 3 , 4 , 5 , 6 ]\n\nReorder the nodes of the linked list to be in the following order:\n\n[ 0 , 6 , 1 , 5 , 2 , 4 , 3 ]\n\nNotice that in the general case for a list of length = n the nodes are reordered to be in the following order:\n\n[0, n-1, 1, n-2, 2, n-3, ...]\n\nYou may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.\n\nExample 1:\n\nInput:head=[2,4,6,8]Output:[2,8,4,6]\n\nExample 2:\n\nInput:head=[2,4,6,8,10]Output:[2,10,4,8,6]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2",
    "dsa": "Reverse And Merge",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/reorder-list/",
    "neetcode_link": "https://neetcode.io/problems/reorder-linked-list?list=neetcode150"
  },
  {
    "uuid": "b42246b5-0ab3-4950-8b31-36d8835f2a3f",
    "card_name": "Remove Nth Node From End of List",
    "description": "You are given the beginning of a linked list head , and an integer n .\n\nRemove the nth node from the end of the list and return the beginning of the list.\n\nExample 1:\n\nInput:head=[1,2,3,4],n=2Output:[1,2,4]\n\nExample 2:\n\nInput:head=[5],n=1Output:[]\n\nExample 3:\n\nInput:head=[1,2],n=2Output:[2]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next\n        return dummy.next",
    "dsa": "Two Pointers",
    "time_complexity": "O(N)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
    "neetcode_link": "https://neetcode.io/problems/remove-node-from-end-of-linked-list?list=neetcode150"
  },
  {
    "uuid": "70465448-3338-4153-86fa-5d56285fc9ba",
    "card_name": "Copy List With Random Pointer",
    "description": "You are given the head of a linked list of length n . Unlike a singly linked list, each node contains an additional pointer random , which may point to any node in the list, or null .\n\nCreate a deep copy of the list.\n\nThe deep copy should consist of exactly n new nodes, each including:\n\nNote: None of the pointers in the new list should point to nodes in the original list.\n\nReturn the head of the copied linked list.\n\nIn the examples, the linked list is represented as a list of n nodes. Each node is represented as a pair of [ val , random_index ] where random_index is the index of the node (0-indexed) that the random pointer points to, or null if it does not point to any node.\n\nExample 1:\n\nInput:head=[[3,null],[7,3],[4,0],[5,1]]Output:[[3,null],[7,3],[4,0],[5,1]]\n\nExample 2:\n\nInput:head=[[1,null],[2,2],[3,2]]Output:[[1,null],[2,2],[3,2]]\n\nConstraints:",
    "python_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if head is None:\n            return None\n\n        l1 = head\n        while l1:\n            l2 = Node(l1.val)\n            l2.next = l1.random\n            l1.random = l2\n            l1 = l1.next\n\n        newHead = head.random\n\n        l1 = head\n        while l1:\n            l2 = l1.random\n            l2.random = l2.next.random if l2.next else None\n            l1 = l1.next\n\n        l1 = head\n        while l1 is not None:\n            l2 = l1.random\n            l1.random = l2.next\n            l2.next = l1.next.random if l1.next else None\n            l1 = l1.next\n\n        return newHead",
    "dsa": "Space Optimized - II",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/copy-list-with-random-pointer/",
    "neetcode_link": "https://neetcode.io/problems/copy-linked-list-with-random-pointer?list=neetcode150"
  },
  {
    "uuid": "a8b45a5d-174e-46dc-8ef5-ff55d22cff02",
    "card_name": "Add Two Numbers",
    "description": "You are given two non-empty linked lists, l1 and l2 , where each represents a non-negative integer.\n\nThe digits are stored in reverse order , e.g. the number 123 is represented as 3 -> 2 -> 1 -> in the linked list.\n\nEach of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nReturn the sum of the two numbers as a linked list.\n\nExample 1:\n\nInput:l1=[1,2,3],l2=[4,5,6]Output:[5,7,9]Explanation:321+654=975.\n\nExample 2:\n\nInput:l1=[9],l2=[9]Output:[8,1]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next",
    "dsa": "Iteration",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/add-two-numbers/",
    "neetcode_link": "https://neetcode.io/problems/add-two-numbers?list=neetcode150"
  },
  {
    "uuid": "e13d8489-3c1d-41de-9bda-2f0862202ee6",
    "card_name": "Find The Duplicate Number",
    "description": "You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [ 1 , n ] inclusive.\n\nEvery integer appears exactly once , except for one integer which appears two or more times . Return the integer that appears more than once.\n\nExample 1:\n\nInput:nums=[1,2,3,2,2]Output:2\n\nExample 2:\n\nInput:nums=[1,2,3,4,4]Output:4\n\nFollow-up: Can you solve the problem without modifying the array nums and using O ( 1 ) O(1) O ( 1 ) extra space?\n\nConstraints:",
    "python_code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow",
    "dsa": "Fast And Slow Pointers",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/find-the-duplicate-number/",
    "neetcode_link": "https://neetcode.io/problems/find-duplicate-integer?list=neetcode150"
  },
  {
    "uuid": "9a44b660-12a2-4ec1-9dee-a215c956a039",
    "card_name": "LRU Cache",
    "description": "Implement the Least Recently Used (LRU) cache class LRUCache . The class should support the following operations\n\nA key is considered used if a get or a put operation is called on it.\n\nEnsure that get and put each run in O ( 1 ) O(1) O ( 1 ) average time complexity.\n\nExample 1:\n\nInput:[\"LRUCache\",[2],\"put\",[1,10],\"get\",[1],\"put\",[2,20],\"put\",[3,30],\"get\",[2],\"get\",[1]]Output:[null,null,10,null,null,20,-1]Explanation:LRUCachelRUCache=newLRUCache(2);lRUCache.put(1,10);// cache: {1=10}lRUCache.get(1);// return 10lRUCache.put(2,20);// cache: {1=10,2=20}lRUCache.put(3,30);// cache: {2=20,3=30},key=1 was evictedlRUCache.get(2);// returns 20lRUCache.get(1);// return -1 (not found)\n\nConstraints:",
    "python_code": "class LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n\n        if len(self.cache) > self.cap:\n            self.cache.popitem(last=False)",
    "dsa": "Built-In Data Structure",
    "time_complexity": "O(1)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/lru-cache/",
    "neetcode_link": "https://neetcode.io/problems/lru-cache?list=neetcode150"
  },
  {
    "uuid": "85bfed1c-1c8e-4274-a6a4-606694f70001",
    "card_name": "Merge K Sorted Lists",
    "description": "You are given an array of k linked lists lists , where each list is sorted in ascending order.\n\nReturn the sorted linked list that is the result of merging all of the individual linked lists.\n\nExample 1:\n\nInput:lists=[[1,2,4],[1,3,5],[3,6]]Output:[1,1,2,3,3,4,5,6]\n\nExample 2:\n\nInput:lists=[]Output:[]\n\nExample 3:\n\nInput:lists=[[]]Output:[]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n\n        return dummy.next",
    "dsa": "Divide And Conquer (Iteration)",
    "time_complexity": "O(n \\log k)",
    "space_complexity": "O(k)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/merge-k-sorted-lists/",
    "neetcode_link": "https://neetcode.io/problems/merge-k-sorted-linked-lists?list=neetcode150"
  },
  {
    "uuid": "5f36c82d-d29d-4038-97a6-b7292facebc5",
    "card_name": "Reverse Nodes In K Group",
    "description": "You are given the head of a singly linked list head and a positive integer k .\n\nYou must reverse the first k nodes in the linked list, and then reverse the next k nodes, and so on. If there are fewer than k nodes left, leave the nodes as they are.\n\nReturn the modified list after reversing the nodes in each group of k .\n\nYou are only allowed to modify the nodes' next pointers, not the values of the nodes.\n\nExample 1:\n\nInput:head=[1,2,3,4,5,6],k=3Output:[3,2,1,6,5,4]\n\nExample 2:\n\nInput:head=[1,2,3,4,5],k=3Output:[3,2,1,4,5]\n\nConstraints:",
    "python_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr",
    "dsa": "Iteration",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
    "neetcode_link": "https://neetcode.io/problems/reverse-nodes-in-k-group?list=neetcode150"
  },
  {
    "uuid": "315b96c7-9f4c-4c38-b6e9-271048eede17",
    "card_name": "Invert Binary Tree",
    "description": "You are given the root of a binary tree root . Invert the binary tree and return its root.\n\nExample 1:\n\nInput:root=[1,2,3,4,5,6,7]Output:[1,3,2,7,6,5,4]\n\nExample 2:\n\nInput:root=[3,2,1]Output:[3,1,2]\n\nExample 3:\n\nInput:root=[]Output:[]\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            node.left, node.right = node.right, node.left\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return root",
    "dsa": "Iterative DFS",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/invert-binary-tree/",
    "neetcode_link": "https://neetcode.io/problems/invert-a-binary-tree?list=neetcode150"
  },
  {
    "uuid": "1b2e4570-2c56-4a30-831c-baa395cb7166",
    "card_name": "Maximum Depth of Binary Tree",
    "description": "Given the root of a binary tree, return its depth .\n\nThe depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nExample 1:\n\nInput:root=[1,2,3,null,null,4]Output:3\n\nExample 2:\n\nInput:root=[]Output:0\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        q = deque()\n        if root:\n            q.append(root)\n\n        level = 0\n        while q:\n            for i in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            level += 1\n        return level",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
    "neetcode_link": "https://neetcode.io/problems/depth-of-binary-tree?list=neetcode150"
  },
  {
    "uuid": "8d68f2dd-399d-4b31-bcff-ed230cfe201e",
    "card_name": "Diameter of Binary Tree",
    "description": "The diameter of a binary tree is defined as the length of the longest path between any two nodes within the tree . The path does not necessarily have to pass through the root.\n\nThe length of a path between two nodes in a binary tree is the number of edges between the nodes. Note that the path can not include the same node twice.\n\nGiven the root of a binary tree root , return the diameter of the tree.\n\nExample 1:\n\nInput:root=[1,null,2,3,4,5]Output:3\n\nExplanation: 3 is the length of the path [ 1 , 2 , 3 , 5 ] or [ 5 , 3 , 2 , 4 ] .\n\nExample 2:\n\nInput:root=[1,2,3]Output:2\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        stack = [root]\n        mp = {None: (0, 0)}\n\n        while stack:\n            node = stack[-1]\n\n            if node.left and node.left not in mp:\n                stack.append(node.left)\n            elif node.right and node.right not in mp:\n                stack.append(node.right)\n            else:\n                node = stack.pop()\n\n                leftHeight, leftDiameter = mp[node.left]\n                rightHeight, rightDiameter = mp[node.right]\n\n                mp[node] = (1 + max(leftHeight, rightHeight),\n                           max(leftHeight + rightHeight, leftDiameter, rightDiameter))\n\n        return mp[root][1]",
    "dsa": "Iterative DFS",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/diameter-of-binary-tree/",
    "neetcode_link": "https://neetcode.io/problems/binary-tree-diameter?list=neetcode150"
  },
  {
    "uuid": "a8c16a19-b237-4ad8-ad7c-b0f4038fba9c",
    "card_name": "Balanced Binary Tree",
    "description": "Given a binary tree, return true if it is height-balanced and false otherwise.\n\nA height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\nExample 1:\n\nInput:root=[1,2,3,null,null,4]Output:true\n\nExample 2:\n\nInput:root=[1,2,3,null,null,4,null,5]Output:false\n\nExample 3:\n\nInput:root=[]Output:true\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root):\n        stack = []\n        node = root\n        last = None\n        depths = {}\n\n        while stack or node:\n            if node:\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack[-1]\n                if not node.right or last == node.right:\n                    stack.pop()\n                    left = depths.get(node.left, 0)\n                    right = depths.get(node.right, 0)\n\n                    if abs(left - right) > 1:\n                        return False\n\n                    depths[node] = 1 + max(left, right)\n                    last = node\n                    node = None\n                else:\n                    node = node.right\n\n        return True",
    "dsa": "Iterative DFS",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/balanced-binary-tree/",
    "neetcode_link": "https://neetcode.io/problems/balanced-binary-tree?list=neetcode150"
  },
  {
    "uuid": "beace9bb-012c-4c36-84d9-5b5c3b5311f8",
    "card_name": "Same Tree",
    "description": "Given the roots of two binary trees p and q , return true if the trees are equivalent , otherwise return false .\n\nTwo binary trees are considered equivalent if they share the exact same structure and the nodes have the same values.\n\nExample 1:\n\nInput:p=[1,2,3],q=[1,2,3]Output:true\n\nExample 2:\n\nInput:p=[4,7],q=[4,null,7]Output:false\n\nExample 3:\n\nInput:p=[1,2,3],q=[1,3,2]Output:false\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        q1 = deque([p])\n        q2 = deque([q])\n\n        while q1 and q2:\n            for _ in range(len(q1)):\n                nodeP = q1.popleft()\n                nodeQ = q2.popleft()\n\n                if nodeP is None and nodeQ is None:\n                    continue\n                if nodeP is None or nodeQ is None or nodeP.val != nodeQ.val:\n                    return False\n\n                q1.append(nodeP.left)\n                q1.append(nodeP.right)\n                q2.append(nodeQ.left)\n                q2.append(nodeQ.right)\n\n        return True",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/same-tree/",
    "neetcode_link": "https://neetcode.io/problems/same-binary-tree?list=neetcode150"
  },
  {
    "uuid": "5ca30fec-c1b8-4af8-8989-ef5d0303194b",
    "card_name": "Subtree of Another Tree",
    "description": "Given the roots of two binary trees root and subRoot , return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\n\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\n\nExample 1:\n\nInput:root=[1,2,3,4,5],subRoot=[2,4,5]Output:true\n\nExample 2:\n\nInput:root=[1,2,3,4,5,null,null,6],subRoot=[2,4,5]Output:false\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        if root == None:\n            return \"$#\"\n\n        return (\"$\" + str(root.val) + self.serialize(root.left) + self.serialize(root.right))\n\n    def z_function(self, s: str) -> list:\n        z = [0] * len(s)\n        l, r, n = 0, 0, len(s)\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        serialized_root = self.serialize(root)\n        serialized_subRoot = self.serialize(subRoot)\n        combined = serialized_subRoot + \"|\" + serialized_root\n\n        z_values = self.z_function(combined)\n        sub_len = len(serialized_subRoot)\n\n        for i in range(sub_len + 1, len(combined)):\n            if z_values[i] == sub_len:\n                return True\n        return False",
    "dsa": "Serialization And Pattern Matching",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(m + n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/subtree-of-another-tree/",
    "neetcode_link": "https://neetcode.io/problems/subtree-of-a-binary-tree?list=neetcode150"
  },
  {
    "uuid": "0ef3d2f0-0437-4655-a8de-49ac41507052",
    "card_name": "Lowest Common Ancestor of a Binary Search Tree",
    "description": "Given a binary search tree (BST) where all node values are unique , and two nodes from the tree p and q , return the lowest common ancestor (LCA) of the two nodes.\n\nThe lowest common ancestor between two nodes p and q is the lowest node in a tree T such that both p and q as descendants. The ancestor is allowed to be a descendant of itself.\n\nExample 1:\n\nInput:root=[5,3,8,1,4,7,9,null,2],p=3,q=8Output:5\n\nExample 2:\n\nInput:root=[5,3,8,1,4,7,9,null,2],p=3,q=4Output:3\n\nExplanation: The LCA of nodes 3 and 4 is 3, since a node can be a descendant of itself.\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        cur = root\n\n        while cur:\n            if p.val > cur.val and q.val > cur.val:\n                cur = cur.right\n            elif p.val < cur.val and q.val < cur.val:\n                cur = cur.left\n            else:\n                return cur",
    "dsa": "Iteration",
    "time_complexity": "O(h)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "neetcode_link": "https://neetcode.io/problems/lowest-common-ancestor-in-binary-search-tree?list=neetcode150"
  },
  {
    "uuid": "209edbe9-aeea-4d16-94a2-731fb8d180a0",
    "card_name": "Binary Tree Level Order Traversal",
    "description": "Given a binary tree root , return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right.\n\nExample 1:\n\nInput:root=[1,2,3,4,5,6,7]Output:[[1],[2,3],[4,5,6,7]]\n\nExample 2:\n\nInput:root=[1]Output:[[1]]\n\nExample 3:\n\nInput:root=[]Output:[]\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        res = []\n\n        q = collections.deque()\n        q.append(root)\n\n        while q:\n            qLen = len(q)\n            level = []\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    level.append(node.val)\n                    q.append(node.left)\n                    q.append(node.right)\n            if level:\n                res.append(level)\n\n        return res",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    "neetcode_link": "https://neetcode.io/problems/level-order-traversal-of-binary-tree?list=neetcode150"
  },
  {
    "uuid": "d1bd9e5d-e24d-4d76-8ebd-39dac7b08f3a",
    "card_name": "Binary Tree Right Side View",
    "description": "You are given the root of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom.\n\nExample 1:\n\nInput:root=[1,2,3]Output:[1,3]\n\nExample 2:\n\nInput:root=[1,2,3,4,5,6,7]Output:[1,3,7]\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        q = deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/binary-tree-right-side-view/",
    "neetcode_link": "https://neetcode.io/problems/binary-tree-right-side-view?list=neetcode150"
  },
  {
    "uuid": "68c3c08a-211a-422b-9984-d77375c3a2a3",
    "card_name": "Count Good Nodes In Binary Tree",
    "description": "Within a binary tree, a node x is considered good if the path from the root of the tree to the node x contains no nodes with a value greater than the value of node x\n\nGiven the root of a binary tree root , return the number of good nodes within the tree.\n\nExample 1:\n\nInput:root=[2,1,1,3,null,1,5]Output:3\n\nExample 2:\n\nInput:root=[1,2,-1,3,4]Output:4\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res = 0\n        q = deque()\n\n        q.append((root,-float('inf')))\n\n        while q:\n            node,maxval = q.popleft()\n            if node.val >= maxval:\n                res += 1\n\n            if node.left:\n                q.append((node.left,max(maxval,node.val)))\n\n            if node.right:\n                q.append((node.right,max(maxval,node.val)))\n\n        return res",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/",
    "neetcode_link": "https://neetcode.io/problems/count-good-nodes-in-binary-tree?list=neetcode150"
  },
  {
    "uuid": "8a1e4b44-2767-4afc-b7c0-7ed03204795e",
    "card_name": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, return true if it is a valid binary search tree , otherwise return false .\n\nA valid binary search tree satisfies the following constraints:\n\nExample 1:\n\nInput:root=[2,1,3]Output:true\n\nExample 2:\n\nInput:root=[1,2,3]Output:false\n\nExplanation: The root node's value is 1 but its left child's value is 2 which is greater than 1.\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n\n        q = deque([(root, float(\"-inf\"), float(\"inf\"))])\n\n        while q:\n            node, left, right = q.popleft()\n            if not (left < node.val < right):\n                return False\n            if node.left:\n                q.append((node.left, left, node.val))\n            if node.right:\n                q.append((node.right, node.val, right))\n\n        return True",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/validate-binary-search-tree/",
    "neetcode_link": "https://neetcode.io/problems/valid-binary-search-tree?list=neetcode150"
  },
  {
    "uuid": "e39e5f65-fd03-4a29-8a84-9c28d358a98d",
    "card_name": "Kth Smallest Element In a Bst",
    "description": "Given the root of a binary search tree, and an integer k , return the kth smallest value ( 1-indexed ) in the tree.\n\nA binary search tree satisfies the following constraints:\n\nExample 1:\n\nInput:root=[2,1,3],k=1Output:1\n\nExample 2:\n\nInput:root=[4,3,5,2,null],k=4Output:5\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        curr = root\n\n        while curr:\n            if not curr.left:\n                k -= 1\n                if k == 0:\n                    return curr.val\n                curr = curr.right\n            else:\n                pred = curr.left\n                while pred.right and pred.right != curr:\n                    pred = pred.right\n\n                if not pred.right:\n                    pred.right = curr\n                    curr = curr.left\n                else:\n                    pred.right = None\n                    k -= 1\n                    if k == 0:\n                        return curr.val\n                    curr = curr.right\n\n        return -1",
    "dsa": "Morris Traversal",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
    "neetcode_link": "https://neetcode.io/problems/kth-smallest-integer-in-bst?list=neetcode150"
  },
  {
    "uuid": "8dfd2b77-7a57-4299-90df-f0393809cec4",
    "card_name": "Construct Binary Tree From Preorder And Inorder Traversal",
    "description": "You are given two integer arrays preorder and inorder .\n\nRebuild the binary tree from the preorder and inorder traversals and return its root.\n\nExample 1:\n\nInput:preorder=[1,2,3,4],inorder=[2,1,3,4]Output:[1,2,3,null,null,null,4]\n\nExample 2:\n\nInput:preorder=[1],inorder=[1]Output:[1]\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        preIdx = inIdx = 0\n        def dfs(limit):\n            nonlocal preIdx, inIdx\n            if preIdx >= len(preorder):\n                return None\n            if inorder[inIdx] == limit:\n                inIdx += 1\n                return None\n\n            root = TreeNode(preorder[preIdx])\n            preIdx += 1\n            root.left = dfs(root.val)\n            root.right = dfs(limit)\n            return root\n        return dfs(float('inf'))",
    "dsa": "Depth First Search (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
    "neetcode_link": "https://neetcode.io/problems/binary-tree-from-preorder-and-inorder-traversal?list=neetcode150"
  },
  {
    "uuid": "096b0e66-02a2-4918-b92f-e687140b50e5",
    "card_name": "Binary Tree Maximum Path Sum",
    "description": "Given the root of a non-empty binary tree, return the maximum path sum of any non-empty path.\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can not appear in the sequence more than once. The path does not necessarily need to include the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nExample 1:\n\nInput:root=[1,2,3]Output:6\n\nExplanation: The path is 2 -> 1 -> 3 with a sum of 2 + 1 + 3 = 6.\n\nExample 2:\n\nInput:root=[-15,10,20,null,null,15,5,-5]Output:40\n\nExplanation: The path is 15 -> 20 -> 5 with a sum of 15 + 20 + 5 = 40.\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = [root.val]\n\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]",
    "dsa": "Depth First Search (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    "neetcode_link": "https://neetcode.io/problems/binary-tree-maximum-path-sum?list=neetcode150"
  },
  {
    "uuid": "d8ae0a3a-487d-4373-ac5d-2eb51d47b267",
    "card_name": "Serialize And Deserialize Binary Tree",
    "description": "Implement an algorithm to serialize and deserialize a binary tree.\n\nSerialization is the process of converting an in-memory structure into a sequence of bits so that it can be stored or sent across a network to be reconstructed later in another computer environment.\n\nYou just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. There is no additional restriction on how your serialization/deserialization algorithm should work.\n\nNote: The input/output format in the examples is the same as how NeetCode serializes a binary tree. You do not necessarily need to follow this format.\n\nExample 1:\n\nInput:root=[1,2,3,null,null,4,5]Output:[1,2,3,null,null,4,5]\n\nExample 2:\n\nInput:root=[]Output:[]\n\nConstraints:",
    "python_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n\n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        if not root:\n            return \"N\"\n        res = []\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if not node:\n                res.append(\"N\")\n            else:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n        return \",\".join(res)\n\n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        vals = data.split(\",\")\n        if vals[0] == \"N\":\n            return None\n        root = TreeNode(int(vals[0]))\n        queue = deque([root])\n        index = 1\n        while queue:\n            node = queue.popleft()\n            if vals[index] != \"N\":\n                node.left = TreeNode(int(vals[index]))\n                queue.append(node.left)\n            index += 1\n            if vals[index] != \"N\":\n                node.right = TreeNode(int(vals[index]))\n                queue.append(node.right)\n            index += 1\n        return root",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    "neetcode_link": "https://neetcode.io/problems/serialize-and-deserialize-binary-tree?list=neetcode150"
  },
  {
    "uuid": "eeb2c637-4ab9-42c6-9723-7afb67190c5b",
    "card_name": "Kth Largest Element In a Stream",
    "description": "Design a class to find the kth largest integer in a stream of values, including duplicates. E.g. the 2nd largest from [1, 2, 3, 3] is 3 . The stream is not necessarily sorted.\n\nImplement the following methods:\n\nExample 1:\n\nInput:[\"KthLargest\",[3,[1,2,3,3]],\"add\",[3],\"add\",[5],\"add\",[6],\"add\",[7],\"add\",[8]]Output:[null,3,3,3,5,6]Explanation:KthLargestkthLargest=newKthLargest(3,[1,2,3,3]);kthLargest.add(3);// return 3kthLargest.add(5);// return 3kthLargest.add(6);// return 3kthLargest.add(7);// return 5kthLargest.add(8);// return 6\n\nConstraints:",
    "python_code": "class KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]",
    "dsa": "Min-Heap",
    "time_complexity": "O(m * \\log k)",
    "space_complexity": "O(k)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
    "neetcode_link": "https://neetcode.io/problems/kth-largest-integer-in-a-stream?list=neetcode150"
  },
  {
    "uuid": "94d312c6-200b-4cd5-ac6b-9ac2f786da2f",
    "card_name": "Last Stone Weight",
    "description": "You are given an array of integers stones where stones[i] represents the weight of the ith stone.\n\nWe want to run a simulation on the stones as follows:\n\nContinue the simulation until there is no more than one stone remaining.\n\nReturn the weight of the last remaining stone or return 0 if none remain.\n\nExample 1:\n\nInput:stones=[2,3,6,2,4]Output:1\n\nExplanation: We smash 6 and 4 and are left with a 2, so the array becomes [2,3,2,2]. We smash 3 and 2 and are left with a 1, so the array becomes [1,2,2]. We smash 2 and 2, so the array becomes [1].\n\nExample 2:\n\nInput:stones=[1,2]Output:1\n\nConstraints:",
    "python_code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n\n        maxStone = max(stones)\n        bucket = [0] * (maxStone + 1)\n        for stone in stones:\n            bucket[stone] += 1\n\n        first = second = maxStone\n        while first > 0:\n            if bucket[first] % 2 == 0:\n                first -= 1\n                continue\n\n            j = min(first - 1, second)\n            while j > 0 and bucket[j] == 0:\n                j -= 1\n\n            if j == 0:\n                return first\n            second = j\n            bucket[first] -= 1\n            bucket[second] -= 1\n            bucket[first - second] += 1\n            first = max(first - second, second)\n        return first",
    "dsa": "Bucket Sort",
    "time_complexity": "O(n + w)",
    "space_complexity": "O(w)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/last-stone-weight/",
    "neetcode_link": "https://neetcode.io/problems/last-stone-weight?list=neetcode150"
  },
  {
    "uuid": "078dfa52-0fce-47cf-b82c-983eec15c300",
    "card_name": "K Closest Points to Origin",
    "description": "You are given an 2-D array points where points[i] = [xi, yi] represents the coordinates of a point on an X-Y axis plane. You are also given an integer k .\n\nReturn the k closest points to the origin (0, 0) .\n\nThe distance between two points is defined as the Euclidean distance ( sqrt((x1 - x2)^2 + (y1 - y2)^2)) .\n\nYou may return the answer in any order .\n\nExample 1:\n\nInput:points=[[0,2],[2,2]],k=1Output:[[0,2]]\n\nExplanation : The distance between (0, 2) and the origin (0, 0) is 2 . The distance between (2, 2) and the origin is sqrt(2^2 + 2^2) = 2.82842 . So the closest point to the origin is (0, 2) .\n\nExample 2:\n\nInput:points=[[0,2],[2,0],[2,2]],k=2Output:[[0,2],[2,0]]\n\nExplanation: The output [2 , 0] , [0 , 2] would also be accepted.\n\nConstraints:",
    "python_code": "class Solution:\n    def kClosest(self, points, k):\n        euclidean = lambda x: x[0] ** 2 + x[1] ** 2\n        def partition(l, r):\n            pivotIdx = r\n            pivotDist = euclidean(points[pivotIdx])\n            i = l\n            for j in range(l, r):\n                if euclidean(points[j]) <= pivotDist:\n                    points[i], points[j] = points[j], points[i]\n                    i += 1\n            points[i], points[r] = points[r], points[i]\n            return i\n\n        L, R = 0, len(points) - 1\n        pivot = len(points)\n\n        while pivot != k:\n            pivot = partition(L, R)\n            if pivot < k:\n                L = pivot + 1\n            else:\n                R = pivot - 1\n        return points[:k]",
    "dsa": "Quick Select",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/k-closest-points-to-origin/",
    "neetcode_link": "https://neetcode.io/problems/k-closest-points-to-origin?list=neetcode150"
  },
  {
    "uuid": "3642972f-3e31-43c1-a6f2-430fa257905f",
    "card_name": "Kth Largest Element In An Array",
    "description": "Given an unsorted array of integers nums and an integer k , return the kth largest element in the array.\n\nBy kth largest element, we mean the kth largest element in the sorted order, not the kth distinct element.\n\nFollow-up: Can you solve it without sorting?\n\nExample 1:\n\nInput:nums=[2,3,1,5,4],k=2Output:4\n\nExample 2:\n\nInput:nums=[2,3,1,1,5,5,4],k=3Output:4\n\nConstraints:",
    "python_code": "class Solution:\n    def partition(self, nums: List[int], left: int, right: int) -> int:\n        mid = (left + right) >> 1\n        nums[mid], nums[left + 1] = nums[left + 1], nums[mid]\n\n        if nums[left] < nums[right]:\n            nums[left], nums[right] = nums[right], nums[left]\n        if nums[left + 1] < nums[right]:\n            nums[left + 1], nums[right] = nums[right], nums[left + 1]\n        if nums[left] < nums[left + 1]:\n            nums[left], nums[left + 1] = nums[left + 1], nums[left]\n\n        pivot = nums[left + 1]\n        i = left + 1\n        j = right\n\n        while True:\n            while True:\n                i += 1\n                if not nums[i] > pivot:\n                    break\n            while True:\n                j -= 1\n                if not nums[j] < pivot:\n                    break\n            if i > j:\n                break\n            nums[i], nums[j] = nums[j], nums[i]\n\n        nums[left + 1], nums[j] = nums[j], nums[left + 1]\n        return j\n\n    def quickSelect(self, nums: List[int], k: int) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while True:\n            if right <= left + 1:\n                if right == left + 1 and nums[right] > nums[left]:\n                    nums[left], nums[right] = nums[right], nums[left]\n                return nums[k]\n\n            j = self.partition(nums, left, right)\n\n            if j >= k:\n                right = j - 1\n            if j <= k:\n                left = j + 1\n\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return self.quickSelect(nums, k - 1)",
    "dsa": "Quick Select (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
    "neetcode_link": "https://neetcode.io/problems/kth-largest-element-in-an-array?list=neetcode150"
  },
  {
    "uuid": "c78b0efa-63ff-4d71-9d86-6358f1873f6a",
    "card_name": "Task Scheduler",
    "description": "You are given an array of CPU  tasks tasks , where tasks[i] is an uppercase english character from A to Z . You are also given an integer n .\n\nEach CPU cycle allows the completion of a single task, and tasks may be completed in any order.\n\nThe only constraint is that identical tasks must be separated by at least n CPU cycles, to cooldown the CPU.\n\nReturn the minimum number of CPU cycles required to complete all tasks.\n\nExample 1:\n\nInput:tasks=[\"X\",\"X\",\"Y\",\"Y\"],n=2Output:5\n\nExplanation: A possible sequence is: X -> Y -> idle -> X -> Y.\n\nExample 2:\n\nInput:tasks=[\"A\",\"A\",\"A\",\"B\",\"C\"],n=3Output:9\n\nExplanation: A possible sequence is: A -> B -> C -> Idle -> A -> Idle -> Idle -> Idle -> A.\n\nConstraints:",
    "python_code": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = [0] * 26\n        for task in tasks:\n            count[ord(task) - ord('A')] += 1\n\n        maxf = max(count)\n        maxCount = 0\n        for i in count:\n            maxCount += 1 if i == maxf else 0\n\n        time = (maxf - 1) * (n + 1) + maxCount\n        return max(len(tasks), time)",
    "dsa": "Math",
    "time_complexity": "O(m)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/task-scheduler/",
    "neetcode_link": "https://neetcode.io/problems/task-scheduling?list=neetcode150"
  },
  {
    "uuid": "8c60adc8-feab-4f4b-8774-ca3d349686ac",
    "card_name": "Design Twitter",
    "description": "Implement a simplified version of Twitter which allows users to post tweets, follow/unfollow each other, and view the 10 most recent tweets within their own news feed.\n\nUsers and tweets are uniquely identified by their IDs (integers).\n\nImplement the following methods:\n\nExample 1:\n\nInput:[\"Twitter\",\"postTweet\",[1,10],\"postTweet\",[2,20],\"getNewsFeed\",[1],\"getNewsFeed\",[2],\"follow\",[1,2],\"getNewsFeed\",[1],\"getNewsFeed\",[2],\"unfollow\",[1,2],\"getNewsFeed\",[1]]Output:[null,null,null,[10],[20],null,[20,10],[20],null,[10]]Explanation:Twittertwitter=newTwitter();twitter.postTweet(1,10);// User 1 posts a new tweet with id = 10.twitter.postTweet(2,20);// User 2 posts a new tweet with id = 20.twitter.getNewsFeed(1);// User 1's news feed should only contain their own tweets -> [10].twitter.getNewsFeed(2);// User 2's news feed should only contain their own tweets -> [20].twitter.follow(1,2);// User 1 follows user 2.twitter.getNewsFeed(1);// User 1's news feed should contain both tweets from user 1 and user 2 -> [20,10].twitter.getNewsFeed(2);// User 2's news feed should still only contain their own tweets -> [20].twitter.unfollow(1,2);// User 1 follows user 2.twitter.getNewsFeed(1);// User 1's news feed should only contain their own tweets -> [10].\n\nConstraints:",
    "python_code": "class Twitter:\n\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        if len(self.tweetMap[userId]) > 10:\n            self.tweetMap[userId].pop(0)\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        minHeap = []\n        self.followMap[userId].add(userId)\n        if len(self.followMap[userId]) >= 10:\n            maxHeap = []\n            for followeeId in self.followMap[userId]:\n                if followeeId in self.tweetMap:\n                    index = len(self.tweetMap[followeeId]) - 1\n                    count, tweetId = self.tweetMap[followeeId][index]\n                    heapq.heappush(maxHeap, [-count, tweetId, followeeId, index - 1])\n                    if len(maxHeap) > 10:\n                        heapq.heappop(maxHeap)\n            while maxHeap:\n                count, tweetId, followeeId, index = heapq.heappop(maxHeap)\n                heapq.heappush(minHeap, [-count, tweetId, followeeId, index])\n        else:\n            for followeeId in self.followMap[userId]:\n                if followeeId in self.tweetMap:\n                    index = len(self.tweetMap[followeeId]) - 1\n                    count, tweetId = self.tweetMap[followeeId][index]\n                    heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)",
    "dsa": "Heap (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(N * m + N * M + n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/design-twitter/",
    "neetcode_link": "https://neetcode.io/problems/design-twitter-feed?list=neetcode150"
  },
  {
    "uuid": "20bf1fbd-d6fa-419a-a147-70c9598837dc",
    "card_name": "Find Median From Data Stream",
    "description": "The median is the middle value in a sorted list of integers. For lists of even length, there is no middle value, so the median is the mean of the two middle values.\n\nFor example:\n\nImplement the MedianFinder class:\n\nExample 1:\n\nInput:[\"MedianFinder\",\"addNum\",\"1\",\"findMedian\",\"addNum\",\"3\"\"findMedian\",\"addNum\",\"2\",\"findMedian\"]Output:[null,null,1.0,null,2.0,null,2.0]Explanation:MedianFindermedianFinder=newMedianFinder();medianFinder.addNum(1);// arr = [1]medianFinder.findMedian();// return 1.0medianFinder.addNum(3);// arr = [1,3]medianFinder.findMedian();// return 2.0medianFinder.addNum(2);// arr[1,2,3]medianFinder.findMedian();// return 2.0\n\nConstraints:",
    "python_code": "class MedianFinder:\n    def __init__(self):\n        # two heaps, large, small, minheap, maxheap\n        # heaps should be equal size\n        self.small, self.large = [], []\n\n    def addNum(self, num: int) -> None:\n        if self.large and num > self.large[0]:\n            heapq.heappush(self.large, num)\n        else:\n            heapq.heappush(self.small, -1 * num)\n\n        if len(self.small) > len(self.large) + 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -1 * self.small[0]\n        elif len(self.large) > len(self.small):\n            return self.large[0]\n        return (-1 * self.small[0] + self.large[0]) / 2.0",
    "dsa": "Heap",
    "time_complexity": "O(m * \\log n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/find-median-from-data-stream/",
    "neetcode_link": "https://neetcode.io/problems/find-median-in-a-data-stream?list=neetcode150"
  },
  {
    "uuid": "307f1694-5d0c-4f5c-a1dd-b08367923e0a",
    "card_name": "Subsets",
    "description": "Given an array nums of unique integers, return all possible subsets of nums .\n\nThe solution set must not contain duplicate subsets. You may return the solution in any order .\n\nExample 1:\n\nInput:nums=[1,2,3]Output:[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput:nums=[7]Output:[[],[7]]\n\nConstraints:",
    "python_code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        res = []\n        for i in range(1 << n):\n            subset = [nums[j] for j in range(n) if (i & (1 << j))]\n            res.append(subset)\n        return res",
    "dsa": "Bit Manipulation",
    "time_complexity": "O(n * 2 ^ n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/subsets/",
    "neetcode_link": "https://neetcode.io/problems/subsets?list=neetcode150"
  },
  {
    "uuid": "7e903921-55fe-41ad-9ea0-5db66c81c6d9",
    "card_name": "Combination Sum",
    "description": "You are given an array of distinct integers nums and a target integer target . Your task is to return a list of all unique combinations of nums where the chosen numbers sum to target .\n\nThe same number may be chosen from nums an unlimited number of times . Two combinations are the same if the frequency of each of the chosen numbers is the same, otherwise they are different.\n\nYou may return the combinations in any order and the order of the numbers in each combination can be in any order .\n\nExample 1:\n\nInput:nums=[2,5,6,9]target=9Output:[[2,2,5],[9]]\n\nExplanation: 2 + 2 + 5 = 9. We use 2 twice, and 5 once. 9 = 9. We use 9 once.\n\nExample 2:\n\nInput:nums=[3,4,5]target=16Output:[[3,3,3,3,4],[3,3,5,5],[4,4,4,4],[3,4,4,5]]\n\nExample 3:\n\nInput:nums=[3]target=5Output:[]\n\nConstraints:",
    "python_code": "class Solution:\n    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n\n            for j in range(i, len(nums)):\n                if total + nums[j] > target:\n                    return\n                cur.append(nums[j])\n                dfs(j, cur, total + nums[j])\n                cur.pop()\n\n        dfs(0, [], 0)\n        return res",
    "dsa": "Backtracking (Optimal)",
    "time_complexity": "O(2 ^ \\frac{t}{m})",
    "space_complexity": "O(\\frac{t}{m})",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/combination-sum/",
    "neetcode_link": "https://neetcode.io/problems/combination-target-sum?list=neetcode150"
  },
  {
    "uuid": "62a9cc89-c6aa-4bb3-9183-b70a6a563af7",
    "card_name": "Combination Sum II",
    "description": "You are given an array of integers candidates , which may contain duplicates, and a target integer target . Your task is to return a list of all unique combinations of candidates where the chosen numbers sum to target .\n\nEach element from candidates may be chosen at most once within a combination. The solution set must not contain duplicate combinations.\n\nYou may return the combinations in any order and the order of the numbers in each combination can be in any order .\n\nExample 1:\n\nInput:candidates=[9,2,2,4,6,1,5],target=8Output:[[1,2,5],[2,2,4],[2,6]]\n\nExample 2:\n\nInput:candidates=[1,2,3,4,5],target=7Output:[[1,2,4],[2,5],[3,4]]\n\nConstraints:",
    "python_code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def dfs(idx, path, cur):\n            if cur == target:\n                res.append(path.copy())\n                return\n            for i in range(idx, len(candidates)):\n                if i > idx and candidates[i] == candidates[i - 1]:\n                    continue\n                if cur + candidates[i] > target:\n                    break\n\n                path.append(candidates[i])\n                dfs(i + 1, path, cur + candidates[i])\n                path.pop()\n\n        dfs(0, [], 0)\n        return res",
    "dsa": "Backtracking (Optimal)",
    "time_complexity": "O(n * 2 ^ n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/combination-sum-ii/",
    "neetcode_link": "https://neetcode.io/problems/combination-target-sum-ii?list=neetcode150"
  },
  {
    "uuid": "3665d799-bf35-4871-91d8-0e7c8007952f",
    "card_name": "Permutations",
    "description": "Given an array nums of unique integers, return all the possible permutations. You may return the answer in any order .\n\nExample 1:\n\nInput:nums=[1,2,3]Output:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nExample 2:\n\nInput:nums=[7]Output:[[7]]\n\nConstraints:",
    "python_code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        self.res = []\n        self.backtrack(nums, 0)\n        return self.res\n\n    def backtrack(self, nums: List[int], idx: int):\n        if idx == len(nums):\n            self.res.append(nums[:])\n            return\n        for i in range(idx, len(nums)):\n            nums[idx], nums[i] = nums[i], nums[idx]\n            self.backtrack(nums, idx + 1)\n            nums[idx], nums[i] = nums[i], nums[idx]",
    "dsa": "Backtracking (Optimal)",
    "time_complexity": "O(n! * n)",
    "space_complexity": "O(n! * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/permutations/",
    "neetcode_link": "https://neetcode.io/problems/permutations?list=neetcode150"
  },
  {
    "uuid": "66365d23-9a31-4e9d-b5a0-1dfd693ea3df",
    "card_name": "Subsets II",
    "description": "You are given an array nums of integers, which may contain duplicates. Return all possible subsets.\n\nThe solution must not contain duplicate subsets. You may return the solution in any order .\n\nExample 1:\n\nInput:nums=[1,2,1]Output:[[],[1],[1,2],[1,1],[1,2,1],[2]]\n\nExample 2:\n\nInput:nums=[7,7]Output:[[],[7],[7,7]]\n\nConstraints:",
    "python_code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        res = [[]]\n        prev_Idx = idx = 0\n\n        for i in range(len(nums)):\n            idx = prev_idx if i >= 1 and nums[i] == nums[i - 1] else 0\n            prev_idx = len(res)\n            for j in range(idx, prev_idx):\n                tmp = res[j].copy()\n                tmp.append(nums[i])\n                res.append(tmp)\n\n        return res",
    "dsa": "Iteration",
    "time_complexity": "O(n * 2 ^ n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/subsets-ii/",
    "neetcode_link": "https://neetcode.io/problems/subsets-ii?list=neetcode150"
  },
  {
    "uuid": "52bf11a9-8bed-4435-9606-d630d845ae83",
    "card_name": "Word Search",
    "description": "Given a 2-D grid of characters board and a string word , return true if the word is present in the grid, otherwise return false .\n\nFor the word to be present it must be possible to form it with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\nExample 1:\n\nInput:board=[[\"A\",\"B\",\"C\",\"D\"],[\"S\",\"A\",\"A\",\"T\"],[\"A\",\"C\",\"A\",\"E\"]],word=\"CAT\"Output:true\n\nExample 2:\n\nInput:board=[[\"A\",\"B\",\"C\",\"D\"],[\"S\",\"A\",\"A\",\"T\"],[\"A\",\"C\",\"A\",\"E\"]],word=\"BAT\"Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True\n            if (r < 0 or c < 0 or r >= ROWS or c >= COLS or\n                word[i] != board[r][c] or board[r][c] == '#'):\n                return False\n\n            board[r][c] = '#'\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n            board[r][c] = word[i]\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r, c, 0):\n                    return True\n        return False",
    "dsa": "Backtracking (Optimal)",
    "time_complexity": "O(m * 4 ^ n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/word-search/",
    "neetcode_link": "https://neetcode.io/problems/search-for-word?list=neetcode150"
  },
  {
    "uuid": "5891a782-bc59-4b04-b3c1-4b2a6aea6695",
    "card_name": "Palindrome Partitioning",
    "description": "Given a string s , split s into substrings where every substring is a palindrome. Return all possible lists of palindromic substrings.\n\nYou may return the solution in any order .\n\nExample 1:\n\nInput:s=\"aab\"Output:[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n\nExample 2:\n\nInput:s=\"a\"Output:[[\"a\"]]\n\nConstraints:",
    "python_code": "class Solution:\n\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for l in range(1, n + 1):\n            for i in range(n - l + 1):\n                dp[i][i + l - 1] = (s[i] == s[i + l - 1] and\n                                    (i + 1 > (i + l - 2) or\n                                    dp[i + 1][i + l - 2]))\n\n        def dfs(i):\n            if i >= n:\n                return [[]]\n\n            ret = []\n            for j in range(i, n):\n                if dp[i][j]:\n                    nxt = dfs(j + 1)\n                    for part in nxt:\n                        cur = [s[i : j + 1]] + part\n                        ret.append(cur)\n            return ret\n\n        return dfs(0)",
    "dsa": "Recursion",
    "time_complexity": "O(n * 2 ^ n)",
    "space_complexity": "O(n ^ 2)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/palindrome-partitioning/",
    "neetcode_link": "https://neetcode.io/problems/palindrome-partitioning?list=neetcode150"
  },
  {
    "uuid": "c9ab29b1-a364-44db-9c22-badb6c872644",
    "card_name": "Letter Combinations of a Phone Number",
    "description": "You are given a string digits made up of digits from 2 through 9 inclusive.\n\nEach digit (not including 1) is mapped to a set of characters as shown below:\n\nA digit could represent any one of the characters it maps to.\n\nReturn all possible letter combinations that digits could represent. You may return the answer in any order .\n\nExample 1:\n\nInput:digits=\"34\"Output:[\"dg\",\"dh\",\"di\",\"eg\",\"eh\",\"ei\",\"fg\",\"fh\",\"fi\"]\n\nExample 2:\n\nInput:digits=\"\"Output:[]\n\nConstraints:",
    "python_code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n\n        res = [\"\"]\n        digitToChar = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"qprs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n\n        for digit in digits:\n            tmp = []\n            for curStr in res:\n                for c in digitToChar[digit]:\n                    tmp.append(curStr + c)\n            res = tmp\n        return res",
    "dsa": "Iteration",
    "time_complexity": "O(n * 4 ^ n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
    "neetcode_link": "https://neetcode.io/problems/combinations-of-a-phone-number?list=neetcode150"
  },
  {
    "uuid": "454a53a7-bfbe-4daa-a5b4-4ec3bb75bba1",
    "card_name": "N Queens",
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard so that no two queens can attack each other.\n\nA queen in a chessboard can attack horizontally, vertically, and diagonally.\n\nGiven an integer n , return all distinct solutions to the n-queens puzzle .\n\nEach solution contains a unique board layout where the queen pieces are placed. 'Q' indicates a queen and '.' indicates an empty space.\n\nYou may return the answer in any order .\n\nExample 1:\n\nInput:n=4Output:[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n\nExplanation: There are two different solutions to the 4-queens puzzle.\n\nExample 2:\n\nInput:n=1Output:[[\"Q\"]]\n\nConstraints:",
    "python_code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = 0\n        posDiag = 0\n        negDiag = 0\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            nonlocal col, posDiag, negDiag\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n            for c in range(n):\n                if ((col & (1 << c)) or (posDiag & (1 << (r + c)))\n                    or (negDiag & (1 << (r - c + n)))):\n                    continue\n                col ^= (1 << c)\n                posDiag ^= (1 << (r + c))\n                negDiag ^= (1 << (r - c + n))\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col ^= (1 << c)\n                posDiag ^= (1 << (r + c))\n                negDiag ^= (1 << (r - c + n))\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res",
    "dsa": "Backtracking (Bit Mask)",
    "time_complexity": "O(n!)",
    "space_complexity": "O(n ^ 2)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/n-queens/",
    "neetcode_link": "https://neetcode.io/problems/n-queens?list=neetcode150"
  },
  {
    "uuid": "e93c12b1-b26e-4fab-9266-81a30dcd3b7d",
    "card_name": "Implement Trie Prefix Tree",
    "description": "A prefix tree (also known as a trie) is a tree data structure used to efficiently store and retrieve keys in a set of strings. Some applications of this data structure include auto-complete and spell checker systems.\n\nImplement the PrefixTree class:\n\nExample 1:\n\nInput:[\"Trie\",\"insert\",\"dog\",\"search\",\"dog\",\"search\",\"do\",\"startsWith\",\"do\",\"insert\",\"do\",\"search\",\"do\"]Output:[null,null,true,false,true,null,true]Explanation:PrefixTreeprefixTree=newPrefixTree();prefixTree.insert(\"dog\");prefixTree.search(\"dog\");// return trueprefixTree.search(\"do\");// return falseprefixTree.startsWith(\"do\");// return trueprefixTree.insert(\"do\");prefixTree.search(\"do\");// return true\n\nConstraints:",
    "python_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = False\n\nclass PrefixTree:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.endOfWord = True\n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return cur.endOfWord\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for c in prefix:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return True",
    "dsa": "Prefix Tree (Hash Map)",
    "time_complexity": "O(n)",
    "space_complexity": "O(t)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/implement-trie-prefix-tree/",
    "neetcode_link": "https://neetcode.io/problems/implement-prefix-tree?list=neetcode150"
  },
  {
    "uuid": "f4b89935-78bc-42b8-a5a8-ce79b6c5398e",
    "card_name": "Design Add And Search Words Data Structure",
    "description": "Design a data structure that supports adding new words and searching for existing words.\n\nImplement the WordDictionary class:\n\nExample 1:\n\nInput:[\"WordDictionary\",\"addWord\",\"day\",\"addWord\",\"bay\",\"addWord\",\"may\",\"search\",\"say\",\"search\",\"day\",\"search\",\".ay\",\"search\",\"b..\"]Output:[null,null,null,null,false,true,true,true]Explanation:WordDictionarywordDictionary=newWordDictionary();wordDictionary.addWord(\"day\");wordDictionary.addWord(\"bay\");wordDictionary.addWord(\"may\");wordDictionary.search(\"say\");// return falsewordDictionary.search(\"day\");// return truewordDictionary.search(\".ay\");// return truewordDictionary.search(\"b..\");// return true\n\nConstraints:",
    "python_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.word = True\n\n    def search(self, word: str) -> bool:\n        def dfs(j, root):\n            cur = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == \".\":\n                    for child in cur.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur.children:\n                        return False\n                    cur = cur.children[c]\n            return cur.word\n\n        return dfs(0, self.root)",
    "dsa": "Depth First Search (Trie)",
    "time_complexity": "O(n)",
    "space_complexity": "O(t + n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
    "neetcode_link": "https://neetcode.io/problems/design-word-search-data-structure?list=neetcode150"
  },
  {
    "uuid": "308c24db-fd13-461d-884f-0dd5e6c6dc33",
    "card_name": "Word Search II",
    "description": "Given a 2-D grid of characters board and a list of strings words , return all words that are present in the grid.\n\nFor a word to be present it must be possible to form the word with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\nExample 1:\n\nInput:board=[[\"a\",\"b\",\"c\",\"d\"],[\"s\",\"a\",\"a\",\"t\"],[\"a\",\"c\",\"k\",\"e\"],[\"a\",\"c\",\"d\",\"n\"]],words=[\"bat\",\"cat\",\"back\",\"backend\",\"stack\"]Output:[\"cat\",\"back\",\"backend\"]\n\nExample 2:\n\nInput:board=[[\"x\",\"o\"],[\"x\",\"o\"]],words=[\"xoxo\"]Output:[]\n\nConstraints:",
    "python_code": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.idx = -1\n        self.refs = 0\n\n    def addWord(self, word, i):\n        cur = self\n        cur.refs += 1\n        for c in word:\n            index = ord(c) - ord('a')\n            if not cur.children[index]:\n                cur.children[index] = TrieNode()\n            cur = cur.children[index]\n            cur.refs += 1\n        cur.idx = i\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for i in range(len(words)):\n            root.addWord(words[i], i)\n\n        ROWS, COLS = len(board), len(board[0])\n        res = []\n\n        def getIndex(c):\n            index = ord(c) - ord('a')\n            return index\n\n        def dfs(r, c, node):\n            if (r < 0 or c < 0 or r >= ROWS or\n                c >= COLS or board[r][c] == '*' or\n                not node.children[getIndex(board[r][c])]):\n                return\n\n            tmp = board[r][c]\n            board[r][c] = '*'\n            prev = node\n            node = node.children[getIndex(tmp)]\n            if node.idx != -1:\n                res.append(words[node.idx])\n                node.idx = -1\n                node.refs -= 1\n                if not node.refs:\n                    prev.children[getIndex(tmp)] = None\n                    node = None\n                    board[r][c] = tmp\n                    return\n\n            dfs(r + 1, c, node)\n            dfs(r - 1, c, node)\n            dfs(r, c + 1, node)\n            dfs(r, c - 1, node)\n\n            board[r][c] = tmp\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root)\n\n        return res",
    "dsa": "Backtracking (Trie)",
    "time_complexity": "O(m * n * 4 * 3 ^ {t - 1} + s)",
    "space_complexity": "O(s)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/word-search-ii/",
    "neetcode_link": "https://neetcode.io/problems/search-for-word-ii?list=neetcode150"
  },
  {
    "uuid": "e8f5bb5b-108f-4f83-9b16-241d78551c0b",
    "card_name": "Number of Islands",
    "description": "Given a 2D grid grid where '1' represents land and '0' represents water, count and return the number of islands.\n\nAn island is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).\n\nExample 1:\n\nInput:grid=[[\"0\",\"1\",\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]Output:1\n\nExample 2:\n\nInput:grid=[[\"1\",\"1\",\"0\",\"0\",\"1\"],[\"1\",\"1\",\"0\",\"0\",\"1\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]Output:4\n\nConstraints:",
    "python_code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] >= self.Size[pv]:\n            self.Size[pu] += self.Size[pv]\n            self.Parent[pv] = pu\n        else:\n            self.Size[pv] += self.Size[pu]\n            self.Parent[pu] = pv\n        return True\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        dsu = DSU(ROWS * COLS)\n\n        def index(r, c):\n            return r * COLS + c\n\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        islands = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == '1':\n                    islands += 1\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if (nr < 0 or nc < 0 or nr >= ROWS or\n                            nc >= COLS or grid[nr][nc] == \"0\"\n                        ):\n                            continue\n\n                        if dsu.union(index(r, c), index(nr, nc)):\n                            islands -= 1\n\n        return islands",
    "dsa": "Disjoint Set Union",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/number-of-islands/",
    "neetcode_link": "https://neetcode.io/problems/count-number-of-islands?list=neetcode150"
  },
  {
    "uuid": "442ad622-5c8a-4af3-bae2-8466d48d2419",
    "card_name": "Max Area of Island",
    "description": "You are given a matrix grid where grid[i] is either a 0 (representing water) or 1 (representing land).\n\nAn island is defined as a group of 1 's connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is defined as the number of cells within the island.\n\nReturn the maximum area of an island in grid . If no island exists, return 0 .\n\nExample 1:\n\nInput:grid=[[0,1,1,0,1],[1,0,1,0,1],[0,1,1,0,1],[0,1,0,0,1]]Output:6\n\nExplanation: 1 's cannot be connected diagonally, so the maximum area of the island is 6 .\n\nConstraints:",
    "python_code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] >= self.Size[pv]:\n            self.Size[pu] += self.Size[pv]\n            self.Parent[pv] = pu\n        else:\n            self.Size[pv] += self.Size[pu]\n            self.Parent[pu] = pv\n        return True\n\n    def getSize(self, node):\n        par = self.find(node)\n        return self.Size[par]\n\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        dsu = DSU(ROWS * COLS)\n\n        def index(r, c):\n            return r * COLS + c\n\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        area = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1:\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if (nr < 0 or nc < 0 or nr >= ROWS or\n                            nc >= COLS or grid[nr][nc] == 0\n                        ):\n                            continue\n\n                        dsu.union(index(r, c), index(nr, nc))\n\n                    area = max(area, dsu.getSize(index(r, c)))\n\n        return area",
    "dsa": "Disjoint Set Union",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/max-area-of-island/",
    "neetcode_link": "https://neetcode.io/problems/max-area-of-island?list=neetcode150"
  },
  {
    "uuid": "fc2a730e-fc23-415f-95fd-df1ff2971083",
    "card_name": "Clone Graph",
    "description": "Given a node in a connected undirected graph, return a deep copy of the graph.\n\nEach node in the graph contains an integer value and a list of its neighbors.\n\nclassNode{publicintval;publicList<Node>neighbors;}\n\nThe graph is shown in the test cases as an adjacency list. An adjacency list is a mapping of nodes to lists, used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nFor simplicity, nodes values are numbered from 1 to n , where n is the total number of nodes in the graph. The index of each node within the adjacency list is the same as the node's value (1-indexed).\n\nThe input node will always be the first node in the graph and have 1 as the value.\n\nExample 1:\n\nInput:adjList=[[2],[1,3],[2]]Output:[[2],[1,3],[2]]\n\nExplanation: There are 3 nodes in the graph. Node 1: val = 1 and neighbors = [2]. Node 2: val = 2 and neighbors = [1, 3]. Node 3: val = 3 and neighbors = [2].\n\nExample 2:\n\nInput:adjList=[[]]Output:[[]]\n\nExplanation: The graph has one node with no neighbors.\n\nExample 3:\n\nInput:adjList=[]Output:[]\n\nExplanation: The graph is empty.\n\nConstraints:",
    "python_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        if not node:\n            return None\n\n        oldToNew = {}\n        oldToNew[node] = Node(node.val)\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n            for nei in cur.neighbors:\n                if nei not in oldToNew:\n                    oldToNew[nei] = Node(nei.val)\n                    q.append(nei)\n                oldToNew[cur].neighbors.append(oldToNew[nei])\n\n        return oldToNew[node]",
    "dsa": "Breadth First Search",
    "time_complexity": "O(V + E)",
    "space_complexity": "O(V)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/clone-graph/",
    "neetcode_link": "https://neetcode.io/problems/clone-graph?list=neetcode150"
  },
  {
    "uuid": "f784c143-e1d5-4d66-a17a-e2d7f4a6683f",
    "card_name": "Walls And Gates",
    "description": "You are given a m  n m \\times n m  n 2D grid initialized with these three possible values:\n\nFill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest then the value should remain INF .\n\nAssume the grid can only be traversed up, down, left, or right.\n\nModify the grid in-place .\n\nExample 1:\n\nInput:[[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]Output:[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]\n\nExample 2:\n\nInput:[[0,-1],[2147483647,2147483647]]Output:[[0,-1],[1,2]]\n\nConstraints:",
    "python_code": "class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        q = deque()\n\n        def addCell(r, c):\n            if (min(r, c) < 0 or r == ROWS or c == COLS or\n                (r, c) in visit or grid[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                grid[r][c] = dist\n                addCell(r + 1, c)\n                addCell(r - 1, c)\n                addCell(r, c + 1)\n                addCell(r, c - 1)\n            dist += 1",
    "dsa": "Multi Source BFS",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/walls-and-gates/",
    "neetcode_link": "https://neetcode.io/problems/islands-and-treasure?list=neetcode150"
  },
  {
    "uuid": "3ffc08b0-f35b-4a3d-abfb-10f2c532295f",
    "card_name": "Rotting Oranges",
    "description": "You are given a 2-D matrix grid . Each cell can have one of three possible values:\n\nEvery minute, if a fresh fruit is horizontally or vertically adjacent to a rotten fruit, then the fresh fruit also becomes rotten.\n\nReturn the minimum number of minutes that must elapse until there are zero fresh fruits remaining. If this state is impossible within the grid, return -1 .\n\nExample 1:\n\nInput:grid=[[1,1,0],[0,1,1],[0,1,2]]Output:4\n\nExample 2:\n\nInput:grid=[[1,0,1],[0,2,0],[1,0,1]]Output:-1\n\nConstraints:",
    "python_code": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        fresh = 0\n        time = 0\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1:\n                    fresh += 1\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        while fresh > 0:\n            flag = False\n            for r in range(ROWS):\n                for c in range(COLS):\n                    if grid[r][c] == 2:\n                        for dr, dc in directions:\n                            row, col = r + dr, c + dc\n                            if (row in range(ROWS) and\n                                col in range(COLS) and\n                                grid[row][col] == 1):\n                                grid[row][col] = 3\n                                fresh -= 1\n                                flag = True\n\n            if not flag:\n                return -1\n\n            for r in range(ROWS):\n                for c in range(COLS):\n                    if grid[r][c] == 3:\n                        grid[r][c] = 2\n\n            time += 1\n\n        return time",
    "dsa": "Breadth First Search (No Queue)",
    "time_complexity": "O((m * n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/rotting-oranges/",
    "neetcode_link": "https://neetcode.io/problems/rotting-fruit?list=neetcode150"
  },
  {
    "uuid": "924f885a-2044-4ea0-ae7d-4c656d9387a9",
    "card_name": "Pacific Atlantic Water Flow",
    "description": "You are given a rectangular island heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c) .\n\nThe islands borders the Pacific Ocean from the top and left sides, and borders the Atlantic Ocean from the bottom and right sides.\n\nWater can flow in four directions (up, down, left, or right) from a cell to a neighboring cell with height equal or lower . Water can also flow into the ocean from cells adjacent to the ocean.\n\nFind all cells where water can flow from that cell to both the Pacific and Atlantic oceans. Return it as a 2D list where each element is a list [ r , c ] representing the row and column of the cell. You may return the answer in any order .\n\nExample 1:\n\nInput:heights=[[4,2,7,3,4],[7,4,6,4,7],[6,3,5,3,6]]Output:[[0,2],[0,4],[1,0],[1,1],[1,2],[1,3],[1,4],[2,0]]\n\nExample 2:\n\nInput:heights=[[1],[1]]Output:[[0,0],[0,1]]\n\nConstraints:",
    "python_code": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        pac = [[False] * COLS for _ in range(ROWS)]\n        atl = [[False] * COLS for _ in range(ROWS)]\n\n        def bfs(source, ocean):\n            q = deque(source)\n            while q:\n                r, c = q.popleft()\n                ocean[r][c] = True\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if (0 <= nr < ROWS and 0 <= nc < COLS and\n                        not ocean[nr][nc] and\n                        heights[nr][nc] >= heights[r][c]\n                    ):\n                        q.append((nr, nc))\n\n        pacific = []\n        atlantic = []\n        for c in range(COLS):\n            pacific.append((0, c))\n            atlantic.append((ROWS - 1, c))\n\n        for r in range(ROWS):\n            pacific.append((r, 0))\n            atlantic.append((r, COLS - 1))\n\n        bfs(pacific, pac)\n        bfs(atlantic, atl)\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if pac[r][c] and atl[r][c]:\n                    res.append([r, c])\n        return res",
    "dsa": "Breadth First Search",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
    "neetcode_link": "https://neetcode.io/problems/pacific-atlantic-water-flow?list=neetcode150"
  },
  {
    "uuid": "560004d8-7f10-49c0-bc50-f7d27d02fa10",
    "card_name": "Surrounded Regions",
    "description": "You are given a 2-D matrix board containing 'X' and 'O' characters.\n\nIf a continous, four-directionally connected group of 'O' s is surrounded by 'X' s, it is considered to be surrounded .\n\nChange all surrounded regions of 'O' s to 'X' s and do so in-place by modifying the input board.\n\nExample 1:\n\nInput:board=[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"O\"]]Output:[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"O\"]]\n\nExplanation: Note that regions that are on the border are not considered surrounded regions.\n\nConstraints:",
    "python_code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] >= self.Size[pv]:\n            self.Size[pu] += self.Size[pv]\n            self.Parent[pv] = pu\n        else:\n            self.Size[pv] += self.Size[pu]\n            self.Parent[pu] = pv\n        return True\n\n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        dsu = DSU(ROWS * COLS + 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] != \"O\":\n                    continue\n                if (r == 0 or c == 0 or\n                    r == (ROWS - 1) or c == (COLS - 1)\n                ):\n                    dsu.union(ROWS * COLS, r * COLS + c)\n                else:\n                    for dx, dy in directions:\n                        nr, nc = r + dx, c + dy\n                        if board[nr][nc] == \"O\":\n                            dsu.union(r * COLS + c, nr * COLS + nc)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if not dsu.connected(ROWS * COLS, r * COLS + c):\n                    board[r][c] = \"X\"",
    "dsa": "Disjoint Set Union",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/surrounded-regions/",
    "neetcode_link": "https://neetcode.io/problems/surrounded-regions?list=neetcode150"
  },
  {
    "uuid": "79a288b3-8f2d-4d1c-b03b-82bd9f97af27",
    "card_name": "Course Schedule",
    "description": "You are given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b first if you want to take course a .\n\nThe pair [ 0 , 1 ] , indicates that must take course 1 before taking course 0 .\n\nThere are a total of numCourses courses you are required to take, labeled from 0 to numCourses - 1 .\n\nReturn true if it is possible to finish all courses, otherwise return false .\n\nExample 1:\n\nInput:numCourses=2,prerequisites=[[0,1]]Output:true\n\nExplanation: First take course 1 (no prerequisites) and then take course 0.\n\nExample 2:\n\nInput:numCourses=2,prerequisites=[[0,1],[1,0]]Output:false\n\nExplanation: In order to take course 1 you must take course 0, and to take course 0 you must take course 1. So it is impossible.\n\nConstraints:",
    "python_code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        indegree = [0] * numCourses\n        adj = [[] for i in range(numCourses)]\n        for src, dst in prerequisites:\n            indegree[dst] += 1\n            adj[src].append(dst)\n\n        q = deque()\n        for n in range(numCourses):\n            if indegree[n] == 0:\n                q.append(n)\n\n        finish = 0\n        while q:\n            node = q.popleft()\n            finish += 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n\n        return finish == numCourses",
    "dsa": "Topological Sort (Kahn's Algorithm)",
    "time_complexity": "O(V + E)",
    "space_complexity": "O(V + E)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/course-schedule/",
    "neetcode_link": "https://neetcode.io/problems/course-schedule?list=neetcode150"
  },
  {
    "uuid": "79ad54f8-6eb3-49f4-9887-78a78161435a",
    "card_name": "Course Schedule II",
    "description": "You are given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b first if you want to take course a .\n\nThere are a total of numCourses courses you are required to take, labeled from 0 to numCourses - 1 .\n\nReturn a valid ordering of courses you can take to finish all courses. If there are many valid answers, return any of them. If it's not possible to finish all courses, return an empty array .\n\nExample 1:\n\nInput:numCourses=3,prerequisites=[[1,0]]Output:[0,1,2]\n\nExplanation: We must ensure that course 0 is taken before course 1.\n\nExample 2:\n\nInput:numCourses=3,prerequisites=[[0,1],[1,2],[2,0]]Output:[]\n\nExplanation: It's impossible to finish all courses.\n\nConstraints:",
    "python_code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(numCourses)]\n        indegree = [0] * numCourses\n        for nxt, pre in prerequisites:\n            indegree[nxt] += 1\n            adj[pre].append(nxt)\n\n        output = []\n\n        def dfs(node):\n            output.append(node)\n            indegree[node] -= 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    dfs(nei)\n\n        for i in range(numCourses):\n            if indegree[i] == 0:\n                dfs(i)\n\n        return output if len(output) == numCourses else []",
    "dsa": "Topological Sort (DFS)",
    "time_complexity": "O(V + E)",
    "space_complexity": "O(V + E)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/course-schedule-ii/",
    "neetcode_link": "https://neetcode.io/problems/course-schedule-ii?list=neetcode150"
  },
  {
    "uuid": "0414ed03-17d0-4048-a8ff-3aa7d374f5e8",
    "card_name": "Graph Valid Tree",
    "description": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\nExample 1:\n\nInput:n=5edges=[[0,1],[0,2],[0,3],[1,4]]Output:true\n\nExample 2:\n\nInput:n=5edges=[[0,1],[1,2],[2,3],[1,3],[1,4]]Output:false\n\nNote:\n\nConstraints:",
    "python_code": "class DSU:\n    def __init__(self, n):\n        self.comps = n\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n\n        self.comps -= 1\n        if self.Size[pu] < self.Size[pv]:\n            pu, pv = pv, pu\n        self.Size[pu] += self.Size[pv]\n        self.Parent[pv] = pu\n        return True\n\n    def components(self):\n        return self.comps\n\nclass Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if len(edges) > n - 1:\n            return False\n\n        dsu = DSU(n)\n        for u, v in edges:\n            if not dsu.union(u, v):\n                return False\n        return dsu.components() == 1",
    "dsa": "Disjoint Set Union",
    "time_complexity": "O(V + (E * (V)",
    "space_complexity": "O(V)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/graph-valid-tree/",
    "neetcode_link": "https://neetcode.io/problems/valid-tree?list=neetcode150"
  },
  {
    "uuid": "3e683f52-c7e9-48d7-98a2-c12700da9511",
    "card_name": "Number of Connected Components In An Undirected Graph",
    "description": "There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph.\n\nThe nodes are numbered from 0 to n - 1 .\n\nReturn the total number of connected components in that graph.\n\nExample 1:\n\nInput:n=3edges=[[0,1],[0,2]]Output:1\n\nExample 2:\n\nInput:n=6edges=[[0,1],[1,2],[2,3],[4,5]]Output:2\n\nConstraints:",
    "python_code": "class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, node):\n        cur = node\n        while cur != self.parent[cur]:\n            self.parent[cur] = self.parent[self.parent[cur]]\n            cur = self.parent[cur]\n        return cur\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.rank[pv] > self.rank[pu]:\n            pu, pv = pv, pu\n        self.parent[pv] = pu\n        self.rank[pu] += self.rank[pv]\n        return True\n\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        dsu = DSU(n)\n        res = n\n        for u, v in edges:\n            if dsu.union(u, v):\n                res -= 1\n        return res",
    "dsa": "Disjoint Set Union (Rank | Size)",
    "time_complexity": "O(V + (E * (V)",
    "space_complexity": "O(V)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
    "neetcode_link": "https://neetcode.io/problems/count-connected-components?list=neetcode150"
  },
  {
    "uuid": "a4a01962-bb3f-466d-98f1-51bf753577f9",
    "card_name": "Redundant Connection",
    "description": "You are given a connected undirected graph with n nodes labeled from 1 to n . Initially, it contained no cycles and consisted of n-1 edges.\n\nWe have now added one additional edge to the graph. The edge has two different vertices chosen from 1 to n , and was not an edge that previously existed in the graph.\n\nThe graph is represented as an array edges of length n where edges[i] = [ai, bi] represents an edge between nodes ai and bi in the graph.\n\nReturn an edge that can be removed so that the graph is still a connected non-cyclical graph. If there are multiple answers, return the edge that appears last in the input edges .\n\nExample 1:\n\nInput:edges=[[1,2],[1,3],[3,4],[2,4]]Output:[2,4]\n\nExample 2:\n\nInput:edges=[[1,2],[1,3],[1,4],[3,4],[4,5]]Output:[3,4]\n\nConstraints:",
    "python_code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        par = [i for i in range(len(edges) + 1)]\n        rank = [1] * (len(edges) + 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]",
    "dsa": "Disjoint Set Union",
    "time_complexity": "O(V + (E * (V)",
    "space_complexity": "O(V)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/redundant-connection/",
    "neetcode_link": "https://neetcode.io/problems/redundant-connection?list=neetcode150"
  },
  {
    "uuid": "893fa8cd-d8bf-4b6c-b5a1-845f5016be08",
    "card_name": "Word Ladder",
    "description": "You are given two words, beginWord and endWord , and also a list of words wordList . All of the given words are of the same length, consisting of lowercase English letters, and are all distinct.\n\nYour goal is to transform beginWord into endWord by following the rules:\n\nReturn the minimum number of words within the transformation sequence needed to obtain the endWord , or 0 if no such sequence exists.\n\nExample 1:\n\nInput:beginWord=\"cat\",endWord=\"sag\",wordList=[\"bat\",\"bag\",\"sag\",\"dag\",\"dot\"]Output:4\n\nExplanation: The transformation sequence is \"cat\" -> \"bat\" -> \"bag\" -> \"sag\" .\n\nExample 2:\n\nInput:beginWord=\"cat\",endWord=\"sag\",wordList=[\"bat\",\"bag\",\"sat\",\"dag\",\"dot\"]Output:0\n\nExplanation: There is no possible transformation sequence from \"cat\" to \"sag\" since the word \"sag\" is not in the wordList.\n\nConstraints:",
    "python_code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList or beginWord == endWord:\n            return 0\n        m = len(wordList[0])\n        wordSet = set(wordList)\n        qb, qe = deque([beginWord]), deque([endWord])\n        fromBegin, fromEnd = {beginWord: 1}, {endWord: 1}\n\n        while qb and qe:\n            if len(qb) > len(qe):\n                qb, qe = qe, qb\n                fromBegin, fromEnd = fromEnd, fromBegin\n            for _ in range(len(qb)):\n                word = qb.popleft()\n                steps = fromBegin[word]\n                for i in range(m):\n                    for c in range(97, 123):\n                        if chr(c) == word[i]:\n                            continue\n                        nei = word[:i] + chr(c) + word[i + 1:]\n                        if nei not in wordSet:\n                            continue\n                        if nei in fromEnd:\n                            return steps + fromEnd[nei]\n                        if nei not in fromBegin:\n                            fromBegin[nei] = steps + 1\n                            qb.append(nei)\n        return 0",
    "dsa": "Meet In The Middle (BFS)",
    "time_complexity": "O(m ^ 2 * n)",
    "space_complexity": "O(m ^ 2 * n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/word-ladder/",
    "neetcode_link": "https://neetcode.io/problems/word-ladder?list=neetcode150"
  },
  {
    "uuid": "8474289d-02de-4cb3-93e9-e3ec21cf54d8",
    "card_name": "Network Delay Time",
    "description": "You are given a network of n directed nodes, labeled from 1 to n . You are also given times , a list of directed edges where times [ i ] = ( ui, vi, ti ) .\n\nYou are also given an integer k , representing the node that we will send a signal from.\n\nReturn the minimum time it takes for all of the n nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return -1 instead.\n\nExample 1:\n\nInput:times=[[1,2,1],[2,3,1],[1,4,4],[3,4,1]],n=4,k=1Output:3\n\nExample 2:\n\nInput:times=[[1,2,1],[2,3,1]],n=3,k=2Output:-1\n\nConstraints:",
    "python_code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1",
    "dsa": "Dijkstra's Algorithm",
    "time_complexity": "O(E \\log V)",
    "space_complexity": "O(V + E)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/network-delay-time/",
    "neetcode_link": "https://neetcode.io/problems/network-delay-time?list=neetcode150"
  },
  {
    "uuid": "9b579762-1e4f-4e6a-9161-25006ad43799",
    "card_name": "Reconstruct Itinerary",
    "description": "You are given a list of flight tickets tickets where tickets[i] = [from_i, to_i] represent the source airport and the destination airport.\n\nEach from_i and to_i consists of three uppercase English letters.\n\nReconstruct the itinerary in order and return it.\n\nAll of the tickets belong to someone who originally departed from \"JFK\" . Your objective is to reconstruct the flight path that this person took, assuming each ticket was used exactly once.\n\nIf there are multiple valid flight paths, return the lexicographically smallest one.\n\nYou may assume all the tickets form at least one valid flight path.\n\nExample 1:\n\nInput:tickets=[[\"BUF\",\"HOU\"],[\"HOU\",\"SEA\"],[\"JFK\",\"BUF\"]]Output:[\"JFK\",\"BUF\",\"HOU\",\"SEA\"]\n\nExample 2:\n\nInput:tickets=[[\"HOU\",\"JFK\"],[\"SEA\",\"JFK\"],[\"JFK\",\"SEA\"],[\"JFK\",\"HOU\"]]Output:[\"JFK\",\"HOU\",\"JFK\",\"SEA\",\"JFK\"]\n\nExplanation: Another possible reconstruction is [ \"JFK\" , \"SEA\" , \"JFK\" , \"HOU\" , \"JFK\" ] but it is lexicographically larger.\n\nConstraints:",
    "python_code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = defaultdict(list)\n        for src, dst in sorted(tickets)[::-1]:\n            adj[src].append(dst)\n\n        stack = [\"JFK\"]\n        res = []\n\n        while stack:\n            curr = stack[-1]\n            if not adj[curr]:\n                res.append(stack.pop())\n            else:\n                stack.append(adj[curr].pop())\n\n        return res[::-1]",
    "dsa": "Hierholzer's Algorithm (Iteration)",
    "time_complexity": "O(E\\log E)",
    "space_complexity": "O(E)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/reconstruct-itinerary/",
    "neetcode_link": "https://neetcode.io/problems/reconstruct-flight-path?list=neetcode150"
  },
  {
    "uuid": "6f70c2df-058f-4167-bd02-3012009c2216",
    "card_name": "Min Cost to Connect All Points",
    "description": "You are given a 2-D integer array points , where points[i] = [xi, yi] . Each points[i] represents a distinct point on a 2-D plane.\n\nThe cost of connecting two points [ xi , yi ] and [ xj , yj ] is the manhattan distance between the two points, i.e. |xi - xj| + |yi - yj| .\n\nReturn the minimum cost to connect all points together, such that there exists exactly one path between each pair of points.\n\nExample 1:\n\nInput:points=[[0,0],[2,2],[3,3],[2,4],[4,2]]Output:10\n\nConstraints:",
    "python_code": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, node = len(points), 0\n        dist = [100000000] * n\n        visit = [False] * n\n        edges, res = 0, 0\n\n        while edges < n - 1:\n            visit[node] = True\n            nextNode = -1\n            for i in range(n):\n                if visit[i]:\n                    continue\n                curDist = (abs(points[i][0] - points[node][0]) +\n                           abs(points[i][1] - points[node][1]))\n                dist[i] = min(dist[i], curDist)\n                if nextNode == -1 or dist[i] < dist[nextNode]:\n                    nextNode = i\n\n            res += dist[nextNode]\n            node = nextNode\n            edges += 1\n\n        return res",
    "dsa": "Prim's Algorithm (Optimal)",
    "time_complexity": "O(n ^ 2)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/min-cost-to-connect-all-points/",
    "neetcode_link": "https://neetcode.io/problems/min-cost-to-connect-points?list=neetcode150"
  },
  {
    "uuid": "7f86a10a-14e6-4b51-94eb-51bdd68a60e4",
    "card_name": "Swim In Rising Water",
    "description": "You are given a square 2-D matrix of distinct integers grid where each integer grid[i][j] represents the elevation at position (i, j) .\n\nRain starts to fall at time = 0 , which causes the water level to rise. At time t , the water level across the entire grid is t .\n\nYou may swim either horizontally or vertically in the grid between two adjacent squares if the original elevation of both squares is less than or equal to the water level at time t .\n\nStarting from the top left square (0, 0) , return the minimum amount of time it will take until it is possible to reach the bottom right square (n - 1, n - 1) .\n\nExample 1:\n\nInput:grid=[[0,1],[2,3]]Output:3\n\nExplanation: For a path to exist to the bottom right square grid[1][1] the water elevation must be at least 3 . At time t = 3 , the water level is 3 .\n\nExample 2:\n\nInput:grid=[[0,1,2,10],[9,14,4,13],[12,3,8,15],[11,5,7,6]]]Output:8\n\nExplanation: The water level must be at least 8 to reach the bottom right square. The path is [ 0 , 1 , 2 , 4 , 8 , 7 , 6 ] .\n\nConstraints:",
    "python_code": "class DSU:\n    def __init__(self, n):\n        self.Parent = list(range(n + 1))\n        self.Size = [1] * (n + 1)\n\n    def find(self, node):\n        if self.Parent[node] != node:\n            self.Parent[node] = self.find(self.Parent[node])\n        return self.Parent[node]\n\n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv:\n            return False\n        if self.Size[pu] < self.Size[pv]:\n            pu, pv = pv, pu\n        self.Size[pu] += self.Size[pv]\n        self.Parent[pv] = pu\n        return True\n\n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        dsu = DSU(N * N)\n        positions = sorted((grid[r][c], r, c) for r in range(N) for c in range(N))\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        for t, r, c in positions:\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < N and 0 <= nc < N and grid[nr][nc] <= t:\n                    dsu.union(r * N + c, nr * N + nc)\n            if dsu.connected(0, N * N - 1):\n                return t",
    "dsa": "Kruskal's Algorithm",
    "time_complexity": "O(n ^ 2 \\log n)",
    "space_complexity": "O(n ^ 2)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/swim-in-rising-water/",
    "neetcode_link": "https://neetcode.io/problems/swim-in-rising-water?list=neetcode150"
  },
  {
    "uuid": "54e3e591-4586-474e-9f16-2dbebded5641",
    "card_name": "Alien Dictionary",
    "description": "There is a foreign language which uses the latin alphabet, but the order among letters is not \"a\", \"b\", \"c\" ... \"z\" as in English.\n\nYou receive a list of non-empty strings words from the dictionary, where the words are sorted lexicographically based on the rules of this new language.\n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return any of them.\n\nA string a is lexicographically smaller than a string b if either of the following is true:\n\nExample 1:\n\nInput:[\"z\",\"o\"]Output:\"zo\"\n\nExplanation: From \"z\" and \"o\", we know 'z' < 'o', so return \"zo\".\n\nExample 2:\n\nInput:[\"hrn\",\"hrf\",\"er\",\"enn\",\"rfnn\"]Output:\"hernf\"\n\nExplanation:\n\nConstraints:",
    "python_code": "class Solution:\n    def foreignDictionary(self, words):\n        adj = {c: set() for w in words for c in w}\n        indegree = {c: 0 for c in adj}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    if w2[j] not in adj[w1[j]]:\n                        adj[w1[j]].add(w2[j])\n                        indegree[w2[j]] += 1\n                    break\n\n        q = deque([c for c in indegree if indegree[c] == 0])\n        res = []\n\n        while q:\n            char = q.popleft()\n            res.append(char)\n            for neighbor in adj[char]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        if len(res) != len(indegree):\n            return \"\"\n\n        return \"\".join(res)",
    "dsa": "Topological Sort (Kahn's Algorithm)",
    "time_complexity": "O(N + V + E)",
    "space_complexity": "O(V + E)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/alien-dictionary/",
    "neetcode_link": "https://neetcode.io/problems/foreign-dictionary?list=neetcode150"
  },
  {
    "uuid": "3e5d3cd8-671b-4fa2-947a-4e42bd5b4fd9",
    "card_name": "Cheapest Flights Within K Stops",
    "description": "There are n airports, labeled from 0 to n - 1 , which are connected by some flights. You are given an array flights where flights[i] = [from_i, to_i, price_i] represents a one-way flight from airport from_i to airport to_i with cost price_i . You may assume there are no duplicate flights and no flights from an airport to itself.\n\nYou are also given three integers src , dst , and k where:\n\nReturn the cheapest price from src to dst with at most k stops, or return -1 if it is impossible.\n\nExample 1:\n\nInput:n=4,flights=[[0,1,200],[1,2,100],[1,3,300],[2,3,100]],src=0,dst=3,k=1Output:500\n\nExplanation: The optimal path with at most 1 stop from airport 0 to 3 is shown in red, with total cost 200 + 300 = 500 . Note that the path [ 0 -> 1 -> 2 -> 3 ] costs only 400, and thus is cheaper, but it requires 2 stops, which is more than k.\n\nExample 2:\n\nInput:n=3,flights=[[1,0,100],[1,2,200],[0,2,100]],src=1,dst=2,k=1Output:200\n\nExplanation: The optimal path with at most 1 stop from airport 1 to 2 is shown in red and has cost 200 .\n\nConstraints:",
    "python_code": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n        adj = [[] for _ in range(n)]\n        for u, v, cst in flights:\n            adj[u].append([v, cst])\n\n        q = deque([(0, src, 0)])\n        while q:\n            cst, node, stops = q.popleft()\n            if stops > k:\n                continue\n\n            for nei, w in adj[node]:\n                nextCost = cst + w\n                if nextCost < prices[nei]:\n                    prices[nei] = nextCost\n                    q.append((nextCost, nei, stops + 1))\n\n        return prices[dst] if prices[dst] != float(\"inf\") else -1",
    "dsa": "Shortest Path Faster Algorithm",
    "time_complexity": "O(n * k)",
    "space_complexity": "O(n + m)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
    "neetcode_link": "https://neetcode.io/problems/cheapest-flight-path?list=neetcode150"
  },
  {
    "uuid": "fb217602-c4f8-4f1c-8938-695ea7507fd1",
    "card_name": "Climbing Stairs",
    "description": "You are given an integer n representing the number of steps to reach the top of a staircase. You can climb with either 1 or 2 steps at a time.\n\nReturn the number of distinct ways to climb to the top of the staircase.\n\nExample 1:\n\nInput:n=2Output:2\n\nExplanation:\n\nExample 2:\n\nInput:n=3Output:3\n\nExplanation:\n\nConstraints:",
    "python_code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        sqrt5 = math.sqrt(5)\n        phi = (1 + sqrt5) / 2\n        psi = (1 - sqrt5) / 2\n        n += 1\n        return round((phi**n - psi**n) / sqrt5)",
    "dsa": "Math",
    "time_complexity": "O(\\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/climbing-stairs/",
    "neetcode_link": "https://neetcode.io/problems/climbing-stairs?list=neetcode150"
  },
  {
    "uuid": "62d6fb13-52f7-4c38-b9d5-e4b5a04292bb",
    "card_name": "Min Cost Climbing Stairs",
    "description": "You are given an array of integers cost where cost[i] is the cost of taking a step from the ith floor of a staircase. After paying the cost, you can step to either the ( i + 1 ) th floor or the ( i + 2 ) th floor.\n\nYou may choose to start at the index 0 or the index 1 floor.\n\nReturn the minimum cost to reach the top of the staircase, i.e. just past the last index in cost .\n\nExample 1:\n\nInput:cost=[1,2,3]Output:2\n\nExplanation: We can start at index = 1 and pay the cost of cost[1] = 2 and take two steps to reach the top. The total cost is 2 .\n\nExample 2:\n\nInput:cost=[1,2,1,2,1,1,1]Output:4\n\nExplanation: Start at index = 0 .\n\nConstraints:",
    "python_code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] += min(cost[i + 1], cost[i + 2])\n\n        return min(cost[0], cost[1])",
    "dsa": "Dynamic Programming (Space Optimized)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/min-cost-climbing-stairs/",
    "neetcode_link": "https://neetcode.io/problems/min-cost-climbing-stairs?list=neetcode150"
  },
  {
    "uuid": "bc348d2e-c61a-4496-bc69-89ae392285d6",
    "card_name": "House Robber",
    "description": "You are given an integer array nums where nums[i] represents the amount of money the i th house has. The houses are arranged in a straight line, i.e. the i th house is the neighbor of the (i-1) th and (i+1) th house.\n\nYou are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.\n\nReturn the maximum amount of money you can rob without alerting the police.\n\nExample 1:\n\nInput:nums=[1,1,3,3]Output:4\n\nExplanation: nums[0] + nums[2] = 1 + 3 = 4 .\n\nExample 2:\n\nInput:nums=[2,9,8,3,6]Output:16\n\nExplanation: nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16 .\n\nConstraints:",
    "python_code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for num in nums:\n            temp = max(num + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2",
    "dsa": "Dynamic Programming (Space Optimized)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/house-robber/",
    "neetcode_link": "https://neetcode.io/problems/house-robber?list=neetcode150"
  },
  {
    "uuid": "972d502a-675c-44e5-b2c3-935b47648be0",
    "card_name": "House Robber II",
    "description": "You are given an integer array nums where nums[i] represents the amount of money the i th house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.\n\nYou are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.\n\nReturn the maximum amount of money you can rob without alerting the police.\n\nExample 1:\n\nInput:nums=[3,4,3]Output:4\n\nExplanation: You cannot rob nums[0] + nums[2] = 6 because nums[0] and nums[2] are adjacent houses. The maximum you can rob is nums[1] = 4 .\n\nExample 2:\n\nInput:nums=[2,9,8,3,6]Output:15\n\nExplanation: You cannot rob nums[0] + nums[2] + nums[4] = 16 because nums[0] and nums[4] are adjacent houses. The maximum you can rob is nums[1] + nums[4] = 15 .\n\nConstraints:",
    "python_code": "class Solution:\n\n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]),\n                            self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n\n        for num in nums:\n            newRob = max(rob1 + num, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2",
    "dsa": "Dynamic Programming (Space Optimized)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/house-robber-ii/",
    "neetcode_link": "https://neetcode.io/problems/house-robber-ii?list=neetcode150"
  },
  {
    "uuid": "29b2a6fc-1775-48d9-94e6-e6a3b9b53003",
    "card_name": "Longest Palindromic Substring",
    "description": "Given a string s , return the longest substring of s that is a palindrome .\n\nA palindrome is a string that reads the same forward and backward.\n\nIf there are multiple palindromic substrings that have the same length, return any one of them.\n\nExample 1:\n\nInput:s=\"ababd\"Output:\"bab\"\n\nExplanation: Both \"aba\" and \"bab\" are valid answers.\n\nExample 2:\n\nInput:s=\"abbc\"Output:\"bb\"\n\nConstraints:",
    "python_code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        def manacher(s):\n            t = '#' + '#'.join(s) + '#'\n            n = len(t)\n            p = [0] * n\n            l, r = 0, 0\n            for i in range(n):\n                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0\n                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0\n                       and t[i + p[i] + 1] == t[i - p[i] - 1]):\n                    p[i] += 1\n                if i + p[i] > r:\n                    l, r = i - p[i], i + p[i]\n            return p\n\n        p = manacher(s)\n        resLen, center_idx = max((v, i) for i, v in enumerate(p))\n        resIdx = (center_idx - resLen) // 2\n        return s[resIdx : resIdx + resLen]",
    "dsa": "Manacher's Algorithm",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/longest-palindromic-substring/",
    "neetcode_link": "https://neetcode.io/problems/longest-palindromic-substring?list=neetcode150"
  },
  {
    "uuid": "17881d18-e49a-4eee-b14f-914bf475b1d9",
    "card_name": "Palindromic Substrings",
    "description": "Given a string s , return the number of substrings within s that are palindromes.\n\nA palindrome is a string that reads the same forward and backward.\n\nExample 1:\n\nInput:s=\"abc\"Output:3\n\nExplanation: \"a\", \"b\", \"c\".\n\nExample 2:\n\nInput:s=\"aaa\"Output:6\n\nExplanation: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Note that different substrings are counted as different palindromes even if the string contents are the same.\n\nConstraints:",
    "python_code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n\n        def manacher(s):\n            t = '#' + '#'.join(s) + '#'\n            n = len(t)\n            p = [0] * n\n            l, r = 0, 0\n            for i in range(n):\n                p[i] = min(r - i, p[l + (r - i)]) if i < r else 0\n                while (i + p[i] + 1 < n and i - p[i] - 1 >= 0\n                       and t[i + p[i] + 1] == t[i - p[i] - 1]):\n                    p[i] += 1\n                if i + p[i] > r:\n                    l, r = i - p[i], i + p[i]\n            return p\n\n        p = manacher(s)\n        res = 0\n        for i in p:\n            res += (i + 1) // 2\n        return res",
    "dsa": "Manacher's Algorithm",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/palindromic-substrings/",
    "neetcode_link": "https://neetcode.io/problems/palindromic-substrings?list=neetcode150"
  },
  {
    "uuid": "764298a2-5789-4e15-8a0d-e833654a8d8b",
    "card_name": "Decode Ways",
    "description": "A string consisting of uppercase english characters can be encoded to a number using the following mapping:\n\n'A'->\"1\"'B'->\"2\"...'Z'->\"26\"\n\nTo decode a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, \"1012\" can be mapped into:\n\nThe grouping (1 01 2) is invalid because 01 cannot be mapped into a letter since it contains a leading zero.\n\nGiven a string s containing only digits, return the number of ways to decode it. You can assume that the answer fits in a 32-bit integer.\n\nExample 1:\n\nInput:s=\"12\"Output:2Explanation:\"12\"could be decoded as\"AB\"(12)or\"L\"(12).\n\nExample 2:\n\nInput:s=\"01\"Output:0\n\nExplanation: \"01\" cannot be decoded because \"01\" cannot be mapped into a letter.\n\nConstraints:",
    "python_code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = dp2 = 0\n        dp1 = 1\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == \"0\":\n                dp = 0\n            else:\n                dp = dp1\n\n            if i + 1 < len(s) and (s[i] == \"1\" or\n               s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                dp += dp2\n            dp, dp1, dp2 = 0, dp, dp1\n        return dp1",
    "dsa": "Dynamic Programming (Space Optimized)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/decode-ways/",
    "neetcode_link": "https://neetcode.io/problems/decode-ways?list=neetcode150"
  },
  {
    "uuid": "429987b2-c21d-4512-9d49-a006f30bb226",
    "card_name": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer amount representing a target amount of money.\n\nReturn the fewest number of coins that you need to make up the exact target amount. If it is impossible to make up the amount, return -1 .\n\nYou may assume that you have an unlimited number of each coin.\n\nExample 1:\n\nInput:coins=[1,5,10],amount=12Output:3\n\nExplanation: 12 = 10 + 1 + 1. Note that we do not have to use every kind coin available.\n\nExample 2:\n\nInput:coins=[2],amount=3Output:-1\n\nExplanation: The amount of 3 cannot be made up with coins of 2.\n\nExample 3:\n\nInput:coins=[1],amount=0Output:0\n\nExplanation: Choosing 0 coins is a valid way to make up 0.\n\nConstraints:",
    "python_code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n\n        q = deque([0])\n        seen = [False] * (amount + 1)\n        seen[0] = True\n        res = 0\n\n        while q:\n            res += 1\n            for _ in range(len(q)):\n                cur = q.popleft()\n                for coin in coins:\n                    nxt = cur + coin\n                    if nxt == amount:\n                        return res\n                    if nxt > amount or seen[nxt]:\n                        continue\n                    seen[nxt] = True\n                    q.append(nxt)\n\n        return -1",
    "dsa": "Breadth First Search",
    "time_complexity": "O(n * t)",
    "space_complexity": "O(t)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/coin-change/",
    "neetcode_link": "https://neetcode.io/problems/coin-change?list=neetcode150"
  },
  {
    "uuid": "571f5fd1-fe5d-4ab7-b4c2-da1bc0157bf9",
    "card_name": "Maximum Product Subarray",
    "description": "Given an integer array nums , find a subarray that has the largest product within the array and return it.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nYou can assume the output will fit into a 32-bit integer.\n\nExample 1:\n\nInput:nums=[1,2,-3,4]Output:4\n\nExample 2:\n\nInput:nums=[-2,-1]Output:2\n\nConstraints:",
    "python_code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        n, res = len(nums), nums[0]\n        prefix = suffix = 0\n\n        for i in range(n):\n            prefix = nums[i] * (prefix or 1)\n            suffix = nums[n - 1 - i] * (suffix or 1)\n            res = max(res, max(prefix, suffix))\n        return res",
    "dsa": "Prefix & Suffix",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/maximum-product-subarray/",
    "neetcode_link": "https://neetcode.io/problems/maximum-product-subarray?list=neetcode150"
  },
  {
    "uuid": "ed57ec4e-ef46-4a7b-8af6-5ce5eba76701",
    "card_name": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict , return true if s can be segmented into a space-separated sequence of dictionary words.\n\nYou are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.\n\nExample 1:\n\nInput:s=\"neetcode\",wordDict=[\"neet\",\"code\"]Output:true\n\nExplanation: Return true because \"neetcode\" can be split into \"neet\" and \"code\".\n\nExample 2:\n\nInput:s=\"applepenapple\",wordDict=[\"apple\",\"pen\",\"ape\"]Output:true\n\nExplanation: Return true because \"applepenapple\" can be split into \"apple\", \"pen\" and \"apple\". Notice that we can reuse words and also not use all the words.\n\nExample 3:\n\nInput:s=\"catsincars\",wordDict=[\"cats\",\"cat\",\"sin\",\"in\",\"car\"]Output:false\n\nConstraints:",
    "python_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n\n    def search(self, s, i, j):\n        node = self.root\n        for idx in range(i, j + 1):\n            if s[idx] not in node.children:\n                return False\n            node = node.children[s[idx]]\n        return node.is_word\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        trie = Trie()\n        for word in wordDict:\n            trie.insert(word)\n\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        t = 0\n        for w in wordDict:\n            t = max(t, len(w))\n\n        for i in range(len(s), -1, -1):\n            for j in range(i, min(len(s), i + t)):\n                if trie.search(s, i, j):\n                    dp[i] = dp[j + 1]\n                    if dp[i]:\n                        break\n\n        return dp[0]",
    "dsa": "Dynamic Programming (Trie)",
    "time_complexity": "O((n * t ^ 2)",
    "space_complexity": "O(n + (m * t)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/word-break/",
    "neetcode_link": "https://neetcode.io/problems/word-break?list=neetcode150"
  },
  {
    "uuid": "1b47a085-84c4-45c4-8270-a6385779c071",
    "card_name": "Longest Increasing Subsequence",
    "description": "Given an integer array nums , return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\nExample 1:\n\nInput:nums=[9,1,4,2,3,3,7]Output:4\n\nExplanation: The longest increasing subsequence is [1,2,3,7], which has a length of 4.\n\nExample 2:\n\nInput:nums=[0,3,1,3,2,3]Output:4\n\nConstraints:",
    "python_code": "from bisect import bisect_left\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        dp = []\n        dp.append(nums[0])\n\n        LIS = 1\n        for i in range(1, len(nums)):\n            if dp[-1] < nums[i]:\n                dp.append(nums[i])\n                LIS += 1\n                continue\n\n            idx = bisect_left(dp, nums[i])\n            dp[idx] = nums[i]\n\n        return LIS",
    "dsa": "Dynamic Programming + Binary Search",
    "time_complexity": "O(n \\log n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/longest-increasing-subsequence/",
    "neetcode_link": "https://neetcode.io/problems/longest-increasing-subsequence?list=neetcode150"
  },
  {
    "uuid": "2b1cee6d-08e9-45bb-821a-314857cc5418",
    "card_name": "Partition Equal Subset Sum",
    "description": "You are given an array of positive integers nums .\n\nReturn true if you can partition the array into two subsets, subset1 and subset2 where sum(subset1) == sum(subset2) . Otherwise, return false .\n\nExample 1:\n\nInput:nums=[1,2,3,4]Output:true\n\nExplanation: The array can be partitioned as [ 1 , 4 ] and [ 2 , 3 ] .\n\nExample 2:\n\nInput:nums=[1,2,3,4,5]Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def canPartition(self, nums: list[int]) -> bool:\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n\n        target = total // 2\n        dp = 1 << 0\n\n        for num in nums:\n            dp |= dp << num\n\n        return (dp & (1 << target)) != 0",
    "dsa": "Dynamic Programming (Bitset)",
    "time_complexity": "O(n * target)",
    "space_complexity": "O(target)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/partition-equal-subset-sum/",
    "neetcode_link": "https://neetcode.io/problems/partition-equal-subset-sum?list=neetcode150"
  },
  {
    "uuid": "958ea286-7e06-43f8-9f6a-9fd14d2311fb",
    "card_name": "Unique Paths",
    "description": "There is an m x n grid where you are allowed to move either down or to the right at any point in time.\n\nGiven the two integers m and n , return the number of possible unique paths that can be taken from the top-left corner of the grid ( grid[0][0] ) to the bottom-right corner ( grid[m - 1][n - 1] ).\n\nYou may assume the output will fit in a 32-bit integer.\n\nExample 1:\n\nInput:m=3,n=6Output:21\n\nExample 2:\n\nInput:m=3,n=3Output:6\n\nConstraints:",
    "python_code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        if m < n:\n            m, n = n, m\n\n        res = j = 1\n        for i in range(m, m + n - 1):\n            res *= i\n            res //= j\n            j += 1\n\n        return res",
    "dsa": "Math",
    "time_complexity": "O(min(m, n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/unique-paths/",
    "neetcode_link": "https://neetcode.io/problems/count-paths?list=neetcode150"
  },
  {
    "uuid": "86ce1011-c3db-4841-a4f6-32ceb84a4c8c",
    "card_name": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2 , return the length of the longest common subsequence between the two strings if one exists, otherwise return 0 .\n\nA subsequence is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\nA common subsequence of two strings is a subsequence that exists in both strings.\n\nExample 1:\n\nInput:text1=\"cat\",text2=\"crabt\"Output:3\n\nExplanation: The longest common subsequence is \"cat\" which has a length of 3.\n\nExample 2:\n\nInput:text1=\"abcd\",text2=\"abcd\"Output:4\n\nExample 3:\n\nInput:text1=\"abcd\",text2=\"efgh\"Output:0\n\nConstraints:",
    "python_code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        if len(text1) < len(text2):\n            text1, text2 = text2, text1\n\n        dp = [0] * (len(text2) + 1)\n\n        for i in range(len(text1) - 1, -1, -1):\n            prev = 0\n            for j in range(len(text2) - 1, -1, -1):\n                temp = dp[j]\n                if text1[i] == text2[j]:\n                    dp[j] = 1 + prev\n                else:\n                    dp[j] = max(dp[j], dp[j + 1])\n                prev = temp\n\n        return dp[0]",
    "dsa": "Dynamic Programming (Optimal)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(min(m, n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/longest-common-subsequence/",
    "neetcode_link": "https://neetcode.io/problems/longest-common-subsequence?list=neetcode150"
  },
  {
    "uuid": "f0848f50-34af-403e-8b4f-31abc335a215",
    "card_name": "Best Time to Buy And Sell Stock With Cooldown",
    "description": "You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.\n\nYou may buy and sell one NeetCoin multiple times with the following restrictions:\n\nYou may complete as many transactions as you like.\n\nReturn the maximum profit you can achieve.\n\nExample 1:\n\nInput:prices=[1,3,4,0,4]Output:6\n\nExplanation: Buy on day 0 (price = 1) and sell on day 1 (price = 3), profit = 3-1 = 2. Then buy on day 3 (price = 0) and sell on day 4 (price = 4), profit = 4-0 = 4. Total profit is 2 + 4 = 6.\n\nExample 2:\n\nInput:prices=[1]Output:0\n\nConstraints:",
    "python_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp1_buy, dp1_sell = 0, 0\n        dp2_buy = 0\n\n        for i in range(n - 1, -1, -1):\n            dp_buy = max(dp1_sell - prices[i], dp1_buy)\n            dp_sell = max(dp2_buy + prices[i], dp1_sell)\n            dp2_buy = dp1_buy\n            dp1_buy, dp1_sell = dp_buy, dp_sell\n\n        return dp1_buy",
    "dsa": "Dynamic Programming (Space Optimized)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",
    "neetcode_link": "https://neetcode.io/problems/buy-and-sell-crypto-with-cooldown?list=neetcode150"
  },
  {
    "uuid": "d40c28a2-3d27-479d-9d26-29dae832b304",
    "card_name": "Coin Change II",
    "description": "You are given an integer array coins representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer amount representing a target amount of money.\n\nReturn the number of distinct combinations that total up to amount . If it's impossible to make up the amount, return 0 .\n\nYou may assume that you have an unlimited number of each coin and that each value in coins is unique.\n\nExample 1:\n\nInput:amount=4,coins=[1,2,3]Output:4\n\nExplanation:\n\nExample 2:\n\nInput:amount=7,coins=[2,4]Output:0\n\nConstraints:",
    "python_code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            for a in range(1, amount + 1):\n                dp[a] += dp[a - coins[i]] if coins[i] <= a else 0\n        return dp[amount]",
    "dsa": "Dynamic Programming (Optimal)",
    "time_complexity": "O(n * a)",
    "space_complexity": "O(a)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/coin-change-ii/",
    "neetcode_link": "https://neetcode.io/problems/coin-change-ii?list=neetcode150"
  },
  {
    "uuid": "fb2919af-c8ae-46c9-90ff-ae7c7ee37238",
    "card_name": "Target Sum",
    "description": "You are given an array of integers nums and an integer target .\n\nFor each number in the array, you can choose to either add or subtract it to a total sum.\n\nIf nums=[1,1] , there are two different ways to sum the input numbers to get a sum of 0 : \"+1-1\" and \"-1+1\" .\n\nReturn the number of different ways that you can build the expression such that the total sum equals target .\n\nExample 1:\n\nInput:nums=[2,2,2],target=2Output:3\n\nExplanation: There are 3 different ways to sum the input numbers to get a sum of 2. +2 +2 -2 = 2 +2 -2 +2 = 2 -2 +2 +2 = 2\n\nConstraints:",
    "python_code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = defaultdict(int)\n        dp[0] = 1\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for total, count in dp.items():\n                next_dp[total + num] += count\n                next_dp[total - num] += count\n            dp = next_dp\n\n        return dp[target]",
    "dsa": "Dynamic Programming (Space Optimized)",
    "time_complexity": "O(n * m)",
    "space_complexity": "O(m)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/target-sum/",
    "neetcode_link": "https://neetcode.io/problems/target-sum?list=neetcode150"
  },
  {
    "uuid": "bbfc040e-6e36-4679-a734-8cd88e2fc0fe",
    "card_name": "Interleaving String",
    "description": "You are given three strings s1 , s2 , and s3 . Return true if s3 is formed by interleaving s1 and s2 together or false otherwise.\n\nInterleaving two strings s and t is done by dividing s and t into n and m substrings respectively, where the following conditions are met\n\nYou may assume that s1 , s2 and s3 consist of lowercase English letters.\n\nExample 1:\n\nInput:s1=\"aaaa\",s2=\"bbbb\",s3=\"aabbbbaa\"Output:true\n\nExplanation: We can split s1 into [ \"aa\" , \"aa\" ] , s2 can remain as \"bbbb\" and s3 is formed by interleaving [ \"aa\" , \"aa\" ] and \"bbbb\" .\n\nExample 2:\n\nInput:s1=\"\",s2=\"\",s3=\"\"Output:true\n\nExample 3:\n\nInput:s1=\"abc\",s2=\"xyz\",s3=\"abxzcy\"Output:false\n\nExplanation: We can't split s3 into [ \"ab\" , \"xz\" , \"cy\" ] as the order of characters is not maintained.\n\nConstraints:",
    "python_code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        if n < m:\n            s1, s2 = s2, s1\n            m, n = n, m\n\n        dp = [False for _ in range(n + 1)]\n        dp[n] = True\n        for i in range(m, -1, -1):\n            nextDp = True\n            for j in range(n - 1, -1, -1):\n                res = False\n                if i < m and s1[i] == s3[i + j] and dp[j]:\n                    res = True\n                if j < n and s2[j] == s3[i + j] and nextDp:\n                    res = True\n                dp[j] = res\n                nextDp = dp[j]\n        return dp[0]",
    "dsa": "Dynamic Programming (Optimal)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(min(m, n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/interleaving-string/",
    "neetcode_link": "https://neetcode.io/problems/interleaving-string?list=neetcode150"
  },
  {
    "uuid": "0b823244-0af6-4443-aebc-59456b034b90",
    "card_name": "Longest Increasing Path In a Matrix",
    "description": "You are given a 2-D grid of integers matrix , where each integer is greater than or equal to 0 .\n\nReturn the length of the longest strictly increasing path within matrix .\n\nFrom each cell within the path, you can move either horizontally or vertically. You may not move diagonally .\n\nExample 1:\n\nInput:matrix=[[5,5,3],[2,3,6],[1,1,1]]Output:4\n\nExplanation: The longest increasing path is [ 1 , 2 , 3 , 6 ] or [ 1 , 2 , 3 , 5 ] .\n\nExample 2:\n\nInput:matrix=[[1,2,3],[2,1,4],[7,6,5]]Output:7\n\nExplanation: The longest increasing path is [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] .\n\nConstraints:",
    "python_code": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n        indegree = [[0] * COLS for _ in range(ROWS)]\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                for d in directions:\n                    nr, nc = d[0] + r, d[1] + c\n                    if (0 <= nr < ROWS and 0 <= nc < COLS and\n                        matrix[nr][nc] < matrix[r][c]\n                    ):\n                        indegree[r][c] += 1\n\n        q = deque()\n        for r in range(ROWS):\n            for c in range(COLS):\n                if indegree[r][c] == 0:\n                    q.append([r, c])\n\n        LIS = 0\n        while q:\n            for _ in range(len(q)):\n                r, c = q.popleft()\n                for d in directions:\n                    nr, nc = r + d[0], c + d[1]\n                    if (0 <= nr < ROWS and 0 <= nc < COLS and\n                        matrix[nr][nc] > matrix[r][c]\n                    ):\n                        indegree[nr][nc] -= 1\n                        if indegree[nr][nc] == 0:\n                            q.append([nr, nc])\n            LIS += 1\n        return LIS",
    "dsa": "Topological Sort (Kahn's Algorithm)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",
    "neetcode_link": "https://neetcode.io/problems/longest-increasing-path-in-matrix?list=neetcode150"
  },
  {
    "uuid": "9d92da09-0649-4cfe-b176-7ba577cfe2e3",
    "card_name": "Distinct Subsequences",
    "description": "You are given two strings s and t , both consisting of english letters.\n\nReturn the number of distinct subsequences of s which are equal to t .\n\nExample 1:\n\nInput:s=\"caaat\",t=\"cat\"Output:3\n\nExplanation: There are 3 ways you can generate \"cat\" from s .\n\nExample 2:\n\nInput:s=\"xxyxy\",t=\"xy\"Output:5\n\nExplanation: There are 5 ways you can generate \"xy\" from s .\n\nConstraints:",
    "python_code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [0] * (n + 1)\n\n        dp[n] = 1\n        for i in range(m - 1, -1, -1):\n            prev = 1\n            for j in range(n - 1, -1, -1):\n                res = dp[j]\n                if s[i] == t[j]:\n                    res += prev\n\n                prev = dp[j]\n                dp[j] = res\n\n        return dp[0]",
    "dsa": "Dynamic Programming (Optimal)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/distinct-subsequences/",
    "neetcode_link": "https://neetcode.io/problems/count-subsequences?list=neetcode150"
  },
  {
    "uuid": "d9ac1b38-09f4-40ed-a224-8e1970ad3c36",
    "card_name": "Edit Distance",
    "description": "You are given two strings word1 and word2 , each consisting of lowercase English letters.\n\nYou are allowed to perform three operations on word1 an unlimited number of times:\n\nReturn the minimum number of operations to make word1 equal word2 .\n\nExample 1:\n\nInput:word1=\"monkeys\",word2=\"money\"Output:2\n\nExplanation: monkeys -> monkey (remove s ) monkey -> monkey (remove k )\n\nExample 2:\n\nInput:word1=\"neatcdee\",word2=\"neetcode\"Output:3\n\nExplanation: neatcdee -> neetcdee (replace a with e ) neetcdee -> neetcde (remove last e ) neetcde -> neetcode (insert o )\n\nConstraints:",
    "python_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        if m < n:\n            m, n = n, m\n            word1, word2 = word2, word1\n\n        dp = [n - i for i in range(n + 1)]\n\n        for i in range(m - 1, -1, -1):\n            nextDp = dp[n]\n            dp[n] = m - i\n            for j in range(n - 1, -1, -1):\n                temp = dp[j]\n                if word1[i] == word2[j]:\n                    dp[j] = nextDp\n                else:\n                    dp[j] = 1 + min(dp[j], dp[j + 1], nextDp)\n                nextDp = temp\n        return dp[0]",
    "dsa": "Dynamic Programming (Optimal)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(min(m, n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/edit-distance/",
    "neetcode_link": "https://neetcode.io/problems/edit-distance?list=neetcode150"
  },
  {
    "uuid": "64a53463-91b9-4ca7-b98e-6a9bf567151b",
    "card_name": "Burst Balloons",
    "description": "You are given an array of integers nums of size n . The ith element represents a balloon with an integer value of nums[i] . You must burst all of the balloons.\n\nIf you burst the ith balloon, you will receive nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then assume the out of bounds value is 1.\n\nReturn the maximum number of coins you can receive by bursting all of the balloons.\n\nExample 1:\n\nInput:nums=[4,2,3,7]Output:143Explanation:nums=[4,2,3,7]-->[4,3,7]-->[4,7]-->[7]-->[]coins=4*2*3+4*3*7+1*4*7+1*7*1=143\n\nConstraints:",
    "python_code": "class Solution:\n    def maxCoins(self, nums):\n        n = len(nums)\n        new_nums = [1] + nums + [1]\n\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        for l in range(n, 0, -1):\n            for r in range(l, n + 1):\n                for i in range(l, r + 1):\n                    coins = new_nums[l - 1] * new_nums[i] * new_nums[r + 1]\n                    coins += dp[l][i - 1] + dp[i + 1][r]\n                    dp[l][r] = max(dp[l][r], coins)\n\n        return dp[1][n]",
    "dsa": "Dynamic Programming (Bottom-Up)",
    "time_complexity": "O(n^3)",
    "space_complexity": "O(n^2)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/burst-balloons/",
    "neetcode_link": "https://neetcode.io/problems/burst-balloons?list=neetcode150"
  },
  {
    "uuid": "ef24a7ed-05bf-42a5-9945-bb354a588467",
    "card_name": "Regular Expression Matching",
    "description": "You are given an input string s consisting of lowercase english letters, and a pattern p consisting of lowercase english letters, as well as '.' , and '*' characters.\n\nReturn true if the pattern matches the entire input string, otherwise return false .\n\nExample 1:\n\nInput:s=\"aa\",p=\".b\"Output:false\n\nExplanation: Regardless of which character we choose for the '.' in the pattern, we cannot match the second character in the input string.\n\nExample 2:\n\nInput:s=\"nnn\",p=\"n*\"Output:true\n\nExplanation: '*' means zero or more of the preceding element, 'n' . We choose 'n' to repeat three times.\n\nExample 3:\n\nInput:s=\"xyz\",p=\".*z\"Output:true\n\nExplanation: The pattern \".*\" means zero or more of any character, so we choose \"..\" to match \"xy\" and \"z\" to match \"z\" .\n\nConstraints:",
    "python_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [False] * (len(p) + 1)\n        dp[len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            dp1 = dp[len(p)]\n            dp[len(p)] = (i == len(s))\n\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n                res = False\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    res = dp[j + 2]\n                    if match:\n                        res |= dp[j]\n                elif match:\n                    res = dp1\n                dp[j], dp1 = res, dp[j]\n\n        return dp[0]",
    "dsa": "Dynamic Programming (Optimal)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(n)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/regular-expression-matching/",
    "neetcode_link": "https://neetcode.io/problems/regular-expression-matching?list=neetcode150"
  },
  {
    "uuid": "0b8b0f60-bc17-46f4-b049-f1aab974d64a",
    "card_name": "Maximum Subarray",
    "description": "Given an array of integers nums , find the subarray with the largest sum and return the sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nExample 1:\n\nInput:nums=[2,-3,4,-2,2,1,-1,4]Output:8\n\nExplanation: The subarray [4,-2,2,1,-1,4] has the largest sum 8.\n\nExample 2:\n\nInput:nums=[-1]Output:-1\n\nConstraints:",
    "python_code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        def dfs(l, r):\n            if l > r:\n                return float(\"-inf\")\n\n            m = (l + r) >> 1\n            leftSum = rightSum = curSum = 0\n            for i in range(m - 1, l - 1, -1):\n                curSum += nums[i]\n                leftSum = max(leftSum, curSum)\n\n            curSum = 0\n            for i in range(m + 1, r + 1):\n                curSum += nums[i]\n                rightSum = max(rightSum, curSum)\n\n            return (max(dfs(l, m - 1),\n                        dfs(m + 1, r),\n                        leftSum + nums[m] + rightSum))\n\n        return dfs(0, len(nums) - 1)",
    "dsa": "Divide & Conquer",
    "time_complexity": "O(n \\log n)",
    "space_complexity": "O(\\log n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/maximum-subarray/",
    "neetcode_link": "https://neetcode.io/problems/maximum-subarray?list=neetcode150"
  },
  {
    "uuid": "ee4125d7-2822-41f7-8999-dd34ae8af477",
    "card_name": "Jump Game",
    "description": "You are given an integer array nums where each element nums[i] indicates your maximum jump length at that position.\n\nReturn true if you can reach the last index starting from index 0 , or false otherwise.\n\nExample 1:\n\nInput:nums=[1,2,0,1,0]Output:true\n\nExplanation: First jump from index 0 to 1, then from index 1 to 3, and lastly from index 3 to 4.\n\nExample 2:\n\nInput:nums=[1,2,1,0,1]Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n                goal = i\n        return goal == 0",
    "dsa": "Greedy",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/jump-game/",
    "neetcode_link": "https://neetcode.io/problems/jump-game?list=neetcode150"
  },
  {
    "uuid": "4cfc70e7-c478-4c40-bba1-5c1f5673766d",
    "card_name": "Jump Game II",
    "description": "You are given an array of integers nums , where nums[i] represents the maximum length of a jump towards the right from index i . For example, if you are at nums[i] , you can jump to any index i + j where:\n\nYou are initially positioned at nums[0] .\n\nReturn the minimum number of jumps to reach the last position in the array (index nums.length - 1 ). You may assume there is always a valid answer.\n\nExample 1:\n\nInput:nums=[2,4,1,1,1,1]Output:2\n\nExplanation: Jump from index 0 to index 1 , then jump from index 1 to the last index.\n\nExample 2:\n\nInput:nums=[2,1,2,1,0]Output:2\n\nConstraints:",
    "python_code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        res = 0\n        l = r = 0\n\n        while r < len(nums) - 1:\n            farthest = 0\n            for i in range(l, r + 1):\n                farthest = max(farthest, i + nums[i])\n            l = r + 1\n            r = farthest\n            res += 1\n        return res",
    "dsa": "Breadth First Search (Greedy)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/jump-game-ii/",
    "neetcode_link": "https://neetcode.io/problems/jump-game-ii?list=neetcode150"
  },
  {
    "uuid": "da8c62b9-ba56-4461-954d-151d9620d5fc",
    "card_name": "Gas Station",
    "description": "There are n gas stations along a circular route. You are given two integer arrays gas and cost where:\n\nYou have a car that can store an unlimited amount of gas, but you begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station's index such that you can travel around the circuit once in the clockwise direction. If it's impossible, then return -1 .\n\nIt's guaranteed that at most one solution exists.\n\nExample 1:\n\nInput:gas=[1,2,3,4],cost=[2,2,4,1]Output:3\n\nExplanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 1 + 1 = 4 Travel to station 1. Your tank = 4 - 2 + 2 = 4 Travel to station 2. Your tank = 4 - 2 + 3 = 5 Travel to station 3. Your tank = 5 - 4 + 4 = 5\n\nExample 2:\n\nInput:gas=[1,2,3],cost=[2,3,2]Output:-1\n\nExplanation: You can't start at station 0 or 1, since there isn't enough gas to travel to the next station. If you start at station 2, you can move to station 0, and then station 1. At station 1 your tank = 0 + 3 - 2 + 1 - 2 = 0. You're stuck at station 1, so you can't travel around the circuit.\n\nConstraints:",
    "python_code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n\n        total = 0\n        res = 0\n        for i in range(len(gas)):\n            total += (gas[i] - cost[i])\n\n            if total < 0:\n                total = 0\n                res = i + 1\n\n        return res",
    "dsa": "Greedy",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/gas-station/",
    "neetcode_link": "https://neetcode.io/problems/gas-station?list=neetcode150"
  },
  {
    "uuid": "f4d4b4e1-e762-4932-9ee8-93f5c410a78d",
    "card_name": "Hand of Straights",
    "description": "You are given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize .\n\nYou want to rearrange the cards into groups so that each group is of size groupSize , and card values are consecutively increasing by 1 .\n\nReturn true if it's possible to rearrange the cards in this way, otherwise, return false .\n\nExample 1:\n\nInput:hand=[1,2,4,2,3,5,3,4],groupSize=4Output:true\n\nExplanation: The cards can be rearranged as [ 1 , 2 , 3 , 4 ] and [ 2 , 3 , 4 , 5 ] .\n\nExample 2:\n\nInput:hand=[1,2,3,3,4,5,6,7],groupSize=4Output:false\n\nExplanation: The closest we can get is [ 1 , 2 , 3 , 4 ] and [ 3 , 5 , 6 , 7 ] , but the cards in the second group are not consecutive.\n\nConstraints:",
    "python_code": "class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        for num in hand:\n            start = num\n            while count[start - 1]:\n                start -= 1\n            while start <= num:\n                while count[start]:\n                    for i in range(start, start + groupSize):\n                        if not count[i]:\n                            return False\n                        count[i] -= 1\n                start += 1\n        return True",
    "dsa": "Hash Map",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/hand-of-straights/",
    "neetcode_link": "https://neetcode.io/problems/hand-of-straights?list=neetcode150"
  },
  {
    "uuid": "1c861286-73ef-4408-8eca-b9ba1705fdb5",
    "card_name": "Merge Triplets to Form Target Triplet",
    "description": "You are given a 2D array of integers triplets , where triplets[i] = [ai, bi, ci] represents the ith triplet . You are also given an array of integers target = [x, y, z] which is the triplet we want to obtain.\n\nTo obtain target , you may apply the following operation on triplets zero or more times:\n\nChoose two different triplets triplets[i] and triplets[j] and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)] . * E.g. if triplets[i] = [1, 3, 1] and triplets[j] = [2, 1, 2] , triplets[j] will be updated to [ max ( 1 , 2 ) , max ( 3 , 1 ) , max ( 1 , 2 ) ] = [ 2 , 3 , 2 ] .\n\nReturn true if it is possible to obtain target as an element of triplets , or false otherwise.\n\nExample 1:\n\nInput:triplets=[[1,2,3],[7,1,1]],target=[7,2,3]Output:true\n\nExplanation: Choose the first and second triplets, update the second triplet to be [max(1, 7), max(2, 1), max(3, 1)] = [7, 2, 3].\n\nExample 2:\n\nInput:triplets=[[2,5,6],[1,4,4],[5,7,5]],target=[5,4,6]Output:false\n\nConstraints:",
    "python_code": "class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        x = y = z = False\n        for t in triplets:\n            x |= (t[0] == target[0] and t[1] <= target[1] and t[2] <= target[2])\n            y |= (t[0] <= target[0] and t[1] == target[1] and t[2] <= target[2])\n            z |= (t[0] <= target[0] and t[1] <= target[1] and t[2] == target[2])\n            if x and y and z:\n                return True\n        return False",
    "dsa": "Greedy (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/merge-triplets-to-form-target-triplet/",
    "neetcode_link": "https://neetcode.io/problems/merge-triplets-to-form-target?list=neetcode150"
  },
  {
    "uuid": "afd2f96e-ee7a-448f-a19a-f6f1f5f83b41",
    "card_name": "Partition Labels",
    "description": "You are given a string s consisting of lowercase english letters.\n\nWe want to split the string into as many substrings as possible, while ensuring that each letter appears in at most one substring.\n\nReturn a list of integers representing the size of these substrings in the order they appear in the string.\n\nExample 1:\n\nInput:s=\"xyxxyzbzbbisl\"Output:[5,5,1,1,1]\n\nExplanation: The string can be split into [ \"xyxxy\" , \"zbzbb\" , \"i\" , \"s\" , \"l\" ] .\n\nExample 2:\n\nInput:s=\"abcabc\"Output:[6]\n\nConstraints:",
    "python_code": "class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        lastIndex = {}\n        for i, c in enumerate(s):\n            lastIndex[c] = i\n\n        res = []\n        size = end = 0\n        for i, c in enumerate(s):\n            size += 1\n            end = max(end, lastIndex[c])\n\n            if i == end:\n                res.append(size)\n                size = 0\n        return res",
    "dsa": "Two Pointers (Greedy)",
    "time_complexity": "O(n)",
    "space_complexity": "O(m)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/partition-labels/",
    "neetcode_link": "https://neetcode.io/problems/partition-labels?list=neetcode150"
  },
  {
    "uuid": "531d910c-4f50-457e-b8a4-bc9afe73ae7b",
    "card_name": "Valid Parenthesis String",
    "description": "You are given a string s which contains only three types of characters: '(' , ')' and '*' .\n\nReturn true if s is valid , otherwise return false .\n\nA string is valid if it follows all of the following rules:\n\nExample 1:\n\nInput:s=\"((**)\"Output:true\n\nExplanation: One of the '*' could be a ')' and the other could be an empty string.\n\nExample 2:\n\nInput:s=\"(((*)\"Output:false\n\nExplanation: The string is not valid because there is an extra '(' at the beginning, regardless of the extra '*' .\n\nConstraints:",
    "python_code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        leftMin, leftMax = 0, 0\n\n        for c in s:\n            if c == \"(\":\n                leftMin, leftMax = leftMin + 1, leftMax + 1\n            elif c == \")\":\n                leftMin, leftMax = leftMin - 1, leftMax - 1\n            else:\n                leftMin, leftMax = leftMin - 1, leftMax + 1\n            if leftMax < 0:\n                return False\n            if leftMin < 0:\n                leftMin = 0\n        return leftMin == 0",
    "dsa": "Greedy",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/valid-parenthesis-string/",
    "neetcode_link": "https://neetcode.io/problems/valid-parenthesis-string?list=neetcode150"
  },
  {
    "uuid": "50734ea1-c2bd-4b4e-b395-c80c2326626e",
    "card_name": "Insert Interval",
    "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] represents the start and the end time of the ith interval. intervals is initially sorted in ascending order by start_i .\n\nYou are given another interval newInterval = [ start , end ] .\n\nInsert newInterval into intervals such that intervals is still sorted in ascending order by start_i and also intervals still does not have any overlapping intervals. You may merge the overlapping intervals if needed.\n\nReturn intervals after adding newInterval .\n\nNote: Intervals are non-overlapping if they have no common point. For example, [1,2] and [3,4] are non-overlapping, but [1,2] and [2,3] are overlapping.\n\nExample 1:\n\nInput:intervals=[[1,3],[4,6]],newInterval=[2,5]Output:[[1,6]]\n\nExample 2:\n\nInput:intervals=[[1,2],[3,5],[9,10]],newInterval=[6,7]Output:[[1,2],[3,5],[6,7],[9,10]]\n\nConstraints:",
    "python_code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [\n                    min(newInterval[0], intervals[i][0]),\n                    max(newInterval[1], intervals[i][1]),\n                ]\n        res.append(newInterval)\n        return res",
    "dsa": "Greedy",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/insert-interval/",
    "neetcode_link": "https://neetcode.io/problems/insert-new-interval?list=neetcode150"
  },
  {
    "uuid": "c6749a6e-5a8d-4e5d-b212-40069d05b4a5",
    "card_name": "Merge Intervals",
    "description": "Given an array of intervals where intervals[i] = [start_i, end_i] , merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nYou may return the answer in any order .\n\nNote: Intervals are non-overlapping if they have no common point. For example, [ 1 , 2 ] and [ 3 , 4 ] are non-overlapping, but [ 1 , 2 ] and [ 2 , 3 ] are overlapping.\n\nExample 1:\n\nInput:intervals=[[1,3],[1,5],[6,7]]Output:[[1,5],[6,7]]\n\nExample 2:\n\nInput:intervals=[[1,2],[2,3]]Output:[[1,3]]\n\nConstraints:",
    "python_code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        max_val = max(interval[0] for interval in intervals)\n\n        mp = [0] * (max_val + 1)\n        for start, end in intervals:\n            mp[start] = max(end + 1, mp[start])\n\n        res = []\n        have = -1\n        interval_start = -1\n        for i in range(len(mp)):\n            if mp[i] != 0:\n                if interval_start == -1:\n                    interval_start = i\n                have = max(mp[i] - 1, have)\n            if have == i:\n                res.append([interval_start, have])\n                have = -1\n                interval_start = -1\n\n        if interval_start != -1:\n            res.append([interval_start, have])\n\n        return res",
    "dsa": "Greedy",
    "time_complexity": "O(n + m)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/merge-intervals/",
    "neetcode_link": "https://neetcode.io/problems/merge-intervals?list=neetcode150"
  },
  {
    "uuid": "ff683220-0321-4d17-b504-d282355c3a07",
    "card_name": "Non Overlapping Intervals",
    "description": "Given an array of intervals intervals where intervals[i] = [start_i, end_i] , return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nNote: Intervals are non-overlapping even if they have a common point. For example, [ 1 , 3 ] and [ 2 , 4 ] are overlapping, but [ 1 , 2 ] and [ 2 , 3 ] are non-overlapping.\n\nExample 1:\n\nInput:intervals=[[1,2],[2,4],[1,4]]Output:1\n\nExplanation: After [1,4] is removed, the rest of the intervals are non-overlapping.\n\nExample 2:\n\nInput:intervals=[[1,2],[2,4]]Output:0\n\nConstraints:",
    "python_code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda pair: pair[1])\n        prevEnd = intervals[0][1]\n        res = 0\n\n        for i in range(1, len(intervals)):\n            if prevEnd > intervals[i][0]:\n                res += 1\n            else:\n                prevEnd = intervals[i][1]\n\n\n        return res",
    "dsa": "Greedy (Sort By End)",
    "time_complexity": "O(n \\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/non-overlapping-intervals/",
    "neetcode_link": "https://neetcode.io/problems/non-overlapping-intervals?list=neetcode150"
  },
  {
    "uuid": "e36eb197-f839-41e7-9ca8-38067c3cd441",
    "card_name": "Meeting Rooms",
    "description": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i) , determine if a person could add all meetings to their schedule without any conflicts.\n\nExample 1:\n\nInput:intervals=[(0,30),(5,10),(15,20)]Output:false\n\nExplanation:\n\nExample 2:\n\nInput:intervals=[(5,8),(9,15)]Output:true\n\nNote:\n\nConstraints:",
    "python_code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        intervals.sort(key=lambda i: i.start)\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i - 1]\n            i2 = intervals[i]\n\n            if i1.end > i2.start:\n                return False\n        return True",
    "dsa": "Sorting",
    "time_complexity": "O(n \\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/meeting-rooms/",
    "neetcode_link": "https://neetcode.io/problems/meeting-schedule?list=neetcode150"
  },
  {
    "uuid": "4472f5d1-58fb-43a1-a1a8-7d8ee81d4697",
    "card_name": "Meeting Rooms II",
    "description": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i) , find the minimum number of days required to schedule all meetings without any conflicts.\n\nNote: (0,8),(8,10) is not considered a conflict at 8.\n\nExample 1:\n\nInput:intervals=[(0,40),(5,10),(15,20)]Output:2\n\nExplanation: day1: (0,40) day2: (5,10),(15,20)\n\nExample 2:\n\nInput:intervals=[(4,9)]Output:1\n\nConstraints:",
    "python_code": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        time = []\n        for i in intervals:\n            time.append((i.start, 1))\n            time.append((i.end, -1))\n\n        time.sort(key=lambda x: (x[0], x[1]))\n\n        res = count = 0\n        for t in time:\n            count += t[1]\n            res = max(res, count)\n        return res",
    "dsa": "Greedy",
    "time_complexity": "O(n \\log n)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/meeting-rooms-ii/",
    "neetcode_link": "https://neetcode.io/problems/meeting-schedule-ii?list=neetcode150"
  },
  {
    "uuid": "a81f1623-144d-48f4-a03c-7ceae1831f1f",
    "card_name": "Minimum Interval to Include Each Query",
    "description": "You are given a 2D integer array intervals , where intervals[i] = [left_i, right_i] represents the ith interval starting at left_i and ending at right_i (inclusive) .\n\nYou are also given an integer array of query points queries . The result of query [ j ] is the length of the shortest interval i such that left_i <= queries[j] <= right_i . If no such interval exists, the result of this query is -1 .\n\nReturn an array output where output[j] is the result of query [ j ] .\n\nNote: The length of an interval is calculated as right_i - left_i + 1 .\n\nExample 1:\n\nInput:intervals=[[1,3],[2,3],[3,7],[6,6]],queries=[2,3,1,7,6,8]Output:[2,2,3,5,1,-1]\n\nExplanation:\n\nConstraints:",
    "python_code": "class SegmentTree:\n    def __init__(self, N):\n        self.n = N\n        self.tree = [float('inf')] * (4 * N)\n        self.lazy = [float('inf')] * (4 * N)\n\n    def propagate(self, treeidx, lo, hi):\n        if self.lazy[treeidx] != float('inf'):\n            self.tree[treeidx] = min(self.tree[treeidx], self.lazy[treeidx])\n            if lo != hi:\n                self.lazy[2 * treeidx + 1] = min(self.lazy[2 * treeidx + 1], self.lazy[treeidx])\n                self.lazy[2 * treeidx + 2] = min(self.lazy[2 * treeidx + 2], self.lazy[treeidx])\n            self.lazy[treeidx] = float('inf')\n\n    def update(self, treeidx, lo, hi, left, right, val):\n        self.propagate(treeidx, lo, hi)\n        if lo > right or hi < left:\n            return\n        if lo >= left and hi <= right:\n            self.lazy[treeidx] = min(self.lazy[treeidx], val)\n            self.propagate(treeidx, lo, hi)\n            return\n        mid = (lo + hi) // 2\n        self.update(2 * treeidx + 1, lo, mid, left, right, val)\n        self.update(2 * treeidx + 2, mid + 1, hi, left, right, val)\n        self.tree[treeidx] = min(self.tree[2 * treeidx + 1], self.tree[2 * treeidx + 2])\n\n    def query(self, treeidx, lo, hi, idx):\n        self.propagate(treeidx, lo, hi)\n        if lo == hi:\n            return self.tree[treeidx]\n        mid = (lo + hi) // 2\n        if idx <= mid:\n            return self.query(2 * treeidx + 1, lo, mid, idx)\n        else:\n            return self.query(2 * treeidx + 2, mid + 1, hi, idx)\n\n    def update_range(self, left, right, val):\n        self.update(0, 0, self.n - 1, left, right, val)\n\n    def query_point(self, idx):\n        return self.query(0, 0, self.n - 1, idx)\n\nclass Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        points = []\n        for interval in intervals:\n            points.append(interval[0])\n            points.append(interval[1])\n        for q in queries:\n            points.append(q)\n\n        # Compress the coordinates\n        points = sorted(set(points))\n        compress = {points[i]: i for i in range(len(points))}\n\n        # Lazy Segment Tree\n        segTree = SegmentTree(len(points))\n\n        for interval in intervals:\n            start = compress[interval[0]]\n            end = compress[interval[1]]\n            length = interval[1] - interval[0] + 1\n            segTree.update_range(start, end, length)\n\n        ans = []\n        for q in queries:\n            idx = compress[q]\n\n            # query for minSize\n            res = segTree.query_point(idx)\n            ans.append(res if res != float('inf') else -1)\n        return ans",
    "dsa": "Min Segment Tree (Lazy Propagation)",
    "time_complexity": "O((n + m)",
    "space_complexity": "O(k)",
    "difficulty": "Hard",
    "leetcode_link": "https://leetcode.com/problems/minimum-interval-to-include-each-query/",
    "neetcode_link": "https://neetcode.io/problems/minimum-interval-including-query?list=neetcode150"
  },
  {
    "uuid": "5dde781d-24a7-4a25-98cc-9a8a2f003253",
    "card_name": "Rotate Image",
    "description": "Given a square n x n matrix of integers matrix , rotate it by 90 degrees clockwise .\n\nYou must rotate the matrix in-place . Do not allocate another 2D matrix and do the rotation.\n\nExample 1:\n\nInput:matrix=[[1,2],[3,4]]Output:[[3,1],[4,2]]\n\nExample 2:\n\nInput:matrix=[[1,2,3],[4,5,6],[7,8,9]]Output:[[7,4,1],[8,5,2],[9,6,3]]\n\nConstraints:",
    "python_code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        # Reverse the matrix vertically\n        matrix.reverse()\n\n        # Transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]",
    "dsa": "Reverse And Transpose",
    "time_complexity": "O(n ^ 2)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/rotate-image/",
    "neetcode_link": "https://neetcode.io/problems/rotate-matrix?list=neetcode150"
  },
  {
    "uuid": "c6eb188e-7569-4bf1-afac-84eb4549de8e",
    "card_name": "Spiral Matrix",
    "description": "Given an m x n matrix of integers matrix , return a list of all elements within the matrix in spiral order .\n\nExample 1:\n\nInput:matrix=[[1,2],[3,4]]Output:[1,2,4,3]\n\nExample 2:\n\nInput:matrix=[[1,2,3],[4,5,6],[7,8,9]]Output:[1,2,3,6,9,8,7,4,5]\n\nExample 3:\n\nInput:matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]]Output:[1,2,3,4,8,12,11,10,9,5,6,7]\n\nConstraints:",
    "python_code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        steps = [len(matrix[0]), len(matrix) - 1]\n\n        r, c, d = 0, -1, 0\n        while steps[d & 1]:\n            for i in range(steps[d & 1]):\n                r += directions[d][0]\n                c += directions[d][1]\n                res.append(matrix[r][c])\n            steps[d & 1] -= 1\n            d += 1\n            d %= 4\n        return res",
    "dsa": "Iteration (Optimal)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/spiral-matrix/",
    "neetcode_link": "https://neetcode.io/problems/spiral-matrix?list=neetcode150"
  },
  {
    "uuid": "892160af-3290-488f-a269-c6069ba118f1",
    "card_name": "Set Matrix Zeroes",
    "description": "Given an m x n matrix of integers matrix , if an element is 0 , set its entire row and column to 0 's.\n\nYou must update the matrix in-place .\n\nFollow up: Could you solve it using O(1) space?\n\nExample 1:\n\nInput:matrix=[[0,1],[1,0]]Output:[[0,0],[0,0]]\n\nExample 2:\n\nInput:matrix=[[1,2,3],[4,0,5],[6,7,8]]Output:[[1,0,3],[0,0,0],[6,0,8]]\n\nConstraints:",
    "python_code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rowZero = False\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    matrix[0][c] = 0\n                    if r > 0:\n                        matrix[r][0] = 0\n                    else:\n                        rowZero = True\n\n        for r in range(1, ROWS):\n            for c in range(1, COLS):\n                if matrix[0][c] == 0 or matrix[r][0] == 0:\n                    matrix[r][c] = 0\n\n        if matrix[0][0] == 0:\n            for r in range(ROWS):\n                matrix[r][0] = 0\n\n        if rowZero:\n            for c in range(COLS):\n                matrix[0][c] = 0",
    "dsa": "Iteration (Space Optimized)",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/set-matrix-zeroes/",
    "neetcode_link": "https://neetcode.io/problems/set-zeroes-in-matrix?list=neetcode150"
  },
  {
    "uuid": "6ffba715-8bc2-4c94-957a-cb7845fe4988",
    "card_name": "Happy Number",
    "description": "A non-cyclical number is an integer defined by the following algorithm:\n\nGiven a positive integer n , return true if it is a non-cyclical number , otherwise return false .\n\nExample 1:\n\nInput:n=100Output:true\n\nExplanation: 1^2 + 0^2 + 0^2 = 1\n\nExample 2:\n\nInput:n=101Output:false\n\nExplanation: 1^2 + 0^2 + 1^2 = 2 2^2 = 4 4^2 = 16 1^2 + 6^2 = 37 3^2 + 7^2 = 58 5^2 + 8^2 = 89 8^2 + 9^2 = 145 1^2 + 4^2 + 5^2 = 42 4^2 + 2^2 = 20 2^2 + 0^2 = 4 (This number has already been seen)\n\nConstraints:",
    "python_code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumOfSquares(n)\n        power = lam = 1\n\n        while slow != fast:\n            if power == lam:\n                slow = fast\n                power *= 2\n                lam = 0\n            fast = self.sumOfSquares(fast)\n            lam += 1\n        return True if fast == 1 else False\n\n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n // 10\n        return output",
    "dsa": "Fast And Slow Pointers - II",
    "time_complexity": "O(\\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/happy-number/",
    "neetcode_link": "https://neetcode.io/problems/non-cyclical-number?list=neetcode150"
  },
  {
    "uuid": "2f2e7843-c887-41da-a338-53d9a75846c5",
    "card_name": "Plus One",
    "description": "You are given an integer array digits , where each digits[i] is the ith digit of a large integer. It is ordered from most significant to least significant digit, and it will not contain any leading zero.\n\nReturn the digits of the given integer after incrementing it by one.\n\nExample 1:\n\nInput:digits=[1,2,3,4]Output:[1,2,3,5]\n\nExplanation 1234 + 1 = 1235 .\n\nExample 2:\n\nInput:digits=[9,9,9]Output:[1,0,0,0]\n\nConstraints:",
    "python_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n\n        return [1] + digits",
    "dsa": "Iteration - II",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/plus-one/",
    "neetcode_link": "https://neetcode.io/problems/plus-one?list=neetcode150"
  },
  {
    "uuid": "c19a748e-15a8-4c9c-97d7-4c06ff7ee310",
    "card_name": "Pow(x, n)",
    "description": "Pow(x, n) is a mathematical function to calculate the value of x raised to the power of n (i.e., x^n ).\n\nGiven a floating-point value x and an integer value n , implement the myPow(x, n) function, which calculates x raised to the power n .\n\nYou may not use any built-in library functions.\n\nExample 1:\n\nInput:x=2.00000,n=5Output:32.00000\n\nExample 2:\n\nInput:x=1.10000,n=10Output:2.59374\n\nExample 3:\n\nInput:x=2.00000,n=-3Output:0.12500\n\nConstraints:",
    "python_code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if x == 0:\n            return 0\n        if n == 0:\n            return 1\n\n        res = 1\n        power = abs(n)\n\n        while power:\n            if power & 1:\n                res *= x\n            x *= x\n            power >>= 1\n\n        return res if n >= 0 else 1 / res",
    "dsa": "Binary Exponentiation (Iterative)",
    "time_complexity": "O(\\log n)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/powx-n/",
    "neetcode_link": "https://neetcode.io/problems/pow-x-n?list=neetcode150"
  },
  {
    "uuid": "abefddd5-ca21-4ecb-9c44-4434b2bfcd5f",
    "card_name": "Multiply Strings",
    "description": "You are given two strings num1 and num2 that represent non-negative integers.\n\nReturn the product of num1 and num2 in the form of a string.\n\nAssume that neither num1 nor num2 contain any leading zero, unless they are the number 0 itself.\n\nNote : You can not use any built-in library to convert the inputs directly into integers.\n\nExample 1:\n\nInput:num1=\"3\",num2=\"4\"Output:\"12\"\n\nExample 2:\n\nInput:num1=\"111\",num2=\"222\"Output:\"24642\"\n\nConstraints:",
    "python_code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if \"0\" in [num1, num2]:\n            return \"0\"\n\n        res = [0] * (len(num1) + len(num2))\n        num1, num2 = num1[::-1], num2[::-1]\n        for i1 in range(len(num1)):\n            for i2 in range(len(num2)):\n                digit = int(num1[i1]) * int(num2[i2])\n                res[i1 + i2] += digit\n                res[i1 + i2 + 1] += res[i1 + i2] // 10\n                res[i1 + i2] = res[i1 + i2] % 10\n\n        res, beg = res[::-1], 0\n        while beg < len(res) and res[beg] == 0:\n            beg += 1\n        res = map(str, res[beg:])\n        return \"\".join(res)",
    "dsa": "Multiplication",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m + n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/multiply-strings/",
    "neetcode_link": "https://neetcode.io/problems/multiply-strings?list=neetcode150"
  },
  {
    "uuid": "67be01ea-a7fe-4d62-a602-0bcd49e62bbe",
    "card_name": "Detect Squares",
    "description": "You are given a stream of points consisting of x-y coordinates on a 2-D plane. Points can be added and queried as follows:\n\nImplement the CountSquares class:\n\nExample 1:\n\nInput:[\"CountSquares\",\"add\",[[1,1]],\"add\",[[2,2]],\"add\",[[1,2]],\"count\",[[2,1]],\"count\",[[3,3]],\"add\",[[2,2]],\"count\",[[2,1]]]Output:[null,null,null,null,1,0,null,2]Explanation:CountSquarescountSquares=newCountSquares();countSquares.add([1,1]);countSquares.add([2,2]);countSquares.add([1,2]);countSquares.count([2,1]);// return 1.countSquares.count([3,3]);// return 0.countSquares.add([2,2]);// Duplicate points are allowed.countSquares.count([2,1]);// return 2.\n\nConstraints:",
    "python_code": "class CountSquares:\n\n    def __init__(self):\n        self.ptsCount = defaultdict(lambda: defaultdict(int))\n\n    def add(self, point: List[int]) -> None:\n        self.ptsCount[point[0]][point[1]] += 1\n\n    def count(self, point: List[int]) -> int:\n        res = 0\n        x1, y1 = point\n        for y2 in self.ptsCount[x1]:\n            side = y2 - y1\n            if side == 0:\n                continue\n\n            x3, x4 = x1 + side, x1 - side\n            res += (self.ptsCount[x1][y2] * self.ptsCount[x3][y1] *\n                    self.ptsCount[x3][y2])\n\n            res += (self.ptsCount[x1][y2] * self.ptsCount[x4][y1] *\n                    self.ptsCount[x4][y2])\n        return res",
    "dsa": "Hash Map - II",
    "time_complexity": "O(1)",
    "space_complexity": "O(n)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/detect-squares/",
    "neetcode_link": "https://neetcode.io/problems/count-squares?list=neetcode150"
  },
  {
    "uuid": "5ddc6350-6b68-40c3-9f21-a67ad7e92c42",
    "card_name": "Single Number",
    "description": "You are given a non-empty array of integers nums . Every integer appears twice except for one.\n\nReturn the integer that appears only once.\n\nYou must implement a solution with O ( n ) O(n) O ( n ) runtime complexity and use only O ( 1 ) O(1) O ( 1 ) extra space.\n\nExample 1:\n\nInput:nums=[3,2,3]Output:2\n\nExample 2:\n\nInput:nums=[7,6,6,7,8]Output:8\n\nConstraints:",
    "python_code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for num in nums:\n            res = num ^ res\n        return res",
    "dsa": "Bit Manipulation",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/single-number/",
    "neetcode_link": "https://neetcode.io/problems/single-number?list=neetcode150"
  },
  {
    "uuid": "6513ee5c-8def-478f-b6a1-c1061931baa9",
    "card_name": "Number of 1 Bits",
    "description": "You are given an unsigned integer n . Return the number of 1 bits in its binary representation.\n\nYou may assume n is a non-negative integer which fits within 32-bits.\n\nExample 1:\n\nInput:n=00000000000000000000000000010111Output:4\n\nExample 2:\n\nInput:n=01111111111111111111111111111101Output:30",
    "python_code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')",
    "dsa": "Built-In Function",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/number-of-1-bits/",
    "neetcode_link": "https://neetcode.io/problems/number-of-one-bits?list=neetcode150"
  },
  {
    "uuid": "e4296276-e61c-415c-af2f-68690def77e7",
    "card_name": "Counting Bits",
    "description": "Given an integer n , count the number of 1 's in the binary representation of every number in the range [ 0 , n ] .\n\nReturn an array output where output[i] is the number of 1 's in the binary representation of i .\n\nExample 1:\n\nInput:n=4Output:[0,1,1,2,1]\n\nExplanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100\n\nConstraints:",
    "python_code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp",
    "dsa": "Bit Manipulation (Optimal)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/counting-bits/",
    "neetcode_link": "https://neetcode.io/problems/counting-bits?list=neetcode150"
  },
  {
    "uuid": "833ff342-2fa0-4414-b6e0-20ab52a03219",
    "card_name": "Reverse Bits",
    "description": "Given a 32-bit unsigned integer n , reverse the bits of the binary representation of n and return the result.\n\nExample 1:\n\nInput:n=00000000000000000000000000010101Output:2818572288(10101000000000000000000000000000)\n\nExplanation: Reversing 00000000000000000000000000010101 , which represents the unsigned integer 21 , gives us 10101000000000000000000000000000 which represents the unsigned integer 2818572288 .",
    "python_code": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = n\n        res = (res >> 16) | (res << 16) & 0xFFFFFFFF\n        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)\n        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)\n        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)\n        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)\n        return res & 0xFFFFFFFF",
    "dsa": "Bit Manipulation (Optimal)",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/reverse-bits/",
    "neetcode_link": "https://neetcode.io/problems/reverse-bits?list=neetcode150"
  },
  {
    "uuid": "e9572d86-4e85-461c-8755-f3ff2b8846f7",
    "card_name": "Missing Number",
    "description": "Given an array nums containing n integers in the range [ 0 , n ] without any duplicates, return the single number in the range that is missing from nums .\n\nFollow-up : Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?\n\nExample 1:\n\nInput:nums=[1,2,3]Output:0\n\nExplanation: Since there are 3 numbers, the range is [0,3]. The missing number is 0 since it does not appear in nums.\n\nExample 2:\n\nInput:nums=[0,2]Output:1\n\nConstraints:",
    "python_code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res += i - nums[i]\n        return res",
    "dsa": "Math",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "difficulty": "Easy",
    "leetcode_link": "https://leetcode.com/problems/missing-number/",
    "neetcode_link": "https://neetcode.io/problems/missing-number?list=neetcode150"
  },
  {
    "uuid": "111b94d8-9bba-48c8-8d02-2bd86769afd6",
    "card_name": "Sum of Two Integers",
    "description": "Given two integers a and b , return the sum of the two integers without using the + and - operators.\n\nExample 1:\n\nInput:a=1,b=1Output:2\n\nExample 2:\n\nInput:a=4,b=7Output:11\n\nConstraints:",
    "python_code": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        mask = 0xFFFFFFFF\n        max_int = 0x7FFFFFFF\n\n        while b != 0:\n            carry = (a & b) << 1\n            a = (a ^ b) & mask\n            b = carry & mask\n\n        return a if a <= max_int else ~(a ^ mask)",
    "dsa": "Bit Manipulation (Optimal)",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/sum-of-two-integers/",
    "neetcode_link": "https://neetcode.io/problems/sum-of-two-integers?list=neetcode150"
  },
  {
    "uuid": "ee50ef8f-8f8e-4a52-aae2-212f951909b2",
    "card_name": "Reverse Integer",
    "description": "You are given a signed 32-bit integer x .\n\nReturn x after reversing each of its digits. After reversing, if x goes outside the signed 32-bit integer range [-2^31, 2^31 - 1] , then return 0 instead.\n\nSolve the problem without using integers that are outside the signed 32-bit integer range.\n\nExample 1:\n\nInput:x=1234Output:4321\n\nExample 2:\n\nInput:x=-1234Output:-4321\n\nExample 3:\n\nInput:x=1234236467Output:0\n\nConstraints:",
    "python_code": "class Solution:\n    def reverse(self, x: int) -> int:\n        MIN = -2147483648  # -2^31,\n        MAX = 2147483647  #  2^31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))\n            x = int(x / 10)\n\n            if res > MAX // 10 or (res == MAX // 10 and digit > MAX % 10):\n                return 0\n            if res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):\n                return 0\n            res = (res * 10) + digit\n\n        return res",
    "dsa": "Iteration",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)",
    "difficulty": "Medium",
    "leetcode_link": "https://leetcode.com/problems/reverse-integer/",
    "neetcode_link": "https://neetcode.io/problems/reverse-integer?list=neetcode150"
  }
]